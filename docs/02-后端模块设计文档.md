# OrAura åç«¯æ¨¡å—è®¾è®¡æ–‡æ¡£ (Go + Gin)

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° OrAura åç«¯æœåŠ¡çš„æ¨¡å—è®¾è®¡ï¼ŒåŒ…æ‹¬ API ç»“æ„ã€è·¯ç”±è®¾è®¡ã€æ•°æ®æ¨¡å‹ã€ä¸­é—´ä»¶é…ç½®å’Œå•å…ƒæµ‹è¯•ç­–ç•¥ã€‚

---

## ğŸš€ API æ¶æ„è®¾è®¡

### 1. **API è®¾è®¡åŸåˆ™**

- **RESTful é£æ ¼**: éµå¾ª REST æ¶æ„è§„èŒƒ
- **ç‰ˆæœ¬æ§åˆ¶**: `/api/v1/` å‰ç¼€ç®¡ç†ç‰ˆæœ¬
- **ä¸€è‡´æ€§**: ç»Ÿä¸€çš„å“åº”æ ¼å¼å’Œé”™è¯¯å¤„ç†
- **å¹‚ç­‰æ€§**: GET/PUT/DELETE æ“ä½œå¹‚ç­‰
- **å®‰å…¨æ€§**: JWT è®¤è¯ + HTTPS ä¼ è¾“

### 2. **API å“åº”æ ¼å¼æ ‡å‡†**

```go
// æ ‡å‡†å“åº”ç»“æ„
type APIResponse struct {
    Success   bool        `json:"success"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    Error     *APIError   `json:"error,omitempty"`
    Timestamp int64       `json:"timestamp"`
    TraceID   string      `json:"trace_id"`
}

// é”™è¯¯å“åº”ç»“æ„
type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}
```

### 3. **åˆ†é¡µå“åº”æ ¼å¼**

```go
type PaginatedResponse struct {
    APIResponse
    Pagination PaginationMeta `json:"pagination"`
}

type PaginationMeta struct {
    Page       int `json:"page"`
    PageSize   int `json:"page_size"`
    TotalCount int `json:"total_count"`
    TotalPages int `json:"total_pages"`
    HasNext    bool `json:"has_next"`
    HasPrev    bool `json:"has_prev"`
}
```

---

## ğŸ›¤ï¸ è·¯ç”±ä¸æ§åˆ¶å™¨ç»“æ„

### 1. **è·¯ç”±åˆ†ç»„è®¾è®¡**

```go
// main.go è·¯ç”±æ³¨å†Œ
func setupRoutes(r *gin.Engine) {
    api := r.Group("/api/v1")

    // å…¬å¼€æ¥å£ (æ— éœ€è®¤è¯)
    public := api.Group("/public")
    {
        public.POST("/auth/register", authController.Register)
        public.POST("/auth/login", authController.Login)
        public.POST("/auth/oauth/google", authController.GoogleOAuth)
        public.POST("/auth/oauth/apple", authController.AppleOAuth)
        public.GET("/health", healthController.Check)
    }

    // éœ€è¦è®¤è¯çš„æ¥å£
    protected := api.Group("/")
    protected.Use(middleware.JWTAuth())
    {
        // ç”¨æˆ·ç›¸å…³
        user := protected.Group("/user")
        {
            user.GET("/profile", userController.GetProfile)
            user.PUT("/profile", userController.UpdateProfile)
            user.DELETE("/account", userController.DeleteAccount)
        }

        // å åœç›¸å…³
        divination := protected.Group("/divination")
        {
            divination.POST("/ask", divinationController.Ask)
            divination.GET("/history", divinationController.GetHistory)
            divination.GET("/:id", divinationController.GetDetail)
            divination.DELETE("/:id", divinationController.Delete)
        }

        // æƒ…ç»ªè¿½è¸ª
        emotion := protected.Group("/emotion")
        {
            emotion.POST("/record", emotionController.Record)
            emotion.GET("/daily", emotionController.GetDaily)
            emotion.GET("/weekly", emotionController.GetWeekly)
            emotion.GET("/monthly", emotionController.GetMonthly)
        }

        // å†¥æƒ³ç›¸å…³
        meditation := protected.Group("/meditation")
        {
            meditation.GET("/courses", meditationController.GetCourses)
            meditation.GET("/course/:id", meditationController.GetCourse)
            meditation.POST("/session/start", meditationController.StartSession)
            meditation.PUT("/session/:id/progress", meditationController.UpdateProgress)
            meditation.GET("/sessions/history", meditationController.GetHistory)
        }

        // ç™½å™ªéŸ³
        whitenoise := protected.Group("/whitenoise")
        {
            whitenoise.GET("/sounds", whitenoiseController.GetSounds)
            whitenoise.POST("/preset", whitenoiseController.CreatePreset)
            whitenoise.GET("/presets", whitenoiseController.GetPresets)
            whitenoise.DELETE("/preset/:id", whitenoiseController.DeletePreset)
        }

        // æ—¥è®°
        journal := protected.Group("/journal")
        {
            journal.POST("/entry", journalController.CreateEntry)
            journal.GET("/entries", journalController.GetEntries)
            journal.GET("/entry/:id", journalController.GetEntry)
            journal.PUT("/entry/:id", journalController.UpdateEntry)
            journal.DELETE("/entry/:id", journalController.DeleteEntry)
            journal.POST("/entry/:id/analyze", journalController.AnalyzeEntry)
        }

        // æ”¯ä»˜è®¢é˜…
        subscription := protected.Group("/subscription")
        {
            subscription.GET("/status", subscriptionController.GetStatus)
            subscription.POST("/create", subscriptionController.Create)
            subscription.POST("/cancel", subscriptionController.Cancel)
            subscription.GET("/receipts", subscriptionController.GetReceipts)
        }
    }

    // ç®¡ç†å‘˜æ¥å£
    admin := api.Group("/admin")
    admin.Use(middleware.JWTAuth(), middleware.AdminOnly())
    {
        admin.GET("/users", adminController.GetUsers)
        admin.GET("/analytics", adminController.GetAnalytics)
        admin.POST("/content/meditation", adminController.CreateMeditation)
        admin.PUT("/content/meditation/:id", adminController.UpdateMeditation)
    }

    // Webhook æ¥å£
    webhook := api.Group("/webhook")
    {
        webhook.POST("/stripe", webhookController.StripeWebhook)
        webhook.POST("/apple", webhookController.AppleWebhook)
        webhook.POST("/google", webhookController.GoogleWebhook)
    }
}
```

### 2. **æ§åˆ¶å™¨ç»“æ„ç¤ºä¾‹**

```go
// controllers/divination_controller.go
type DivinationController struct {
    divinationService *services.DivinationService
    aiService         *services.AIService
    logger           *logrus.Logger
}

func NewDivinationController(
    divinationService *services.DivinationService,
    aiService *services.AIService,
    logger *logrus.Logger,
) *DivinationController {
    return &DivinationController{
        divinationService: divinationService,
        aiService:         aiService,
        logger:           logger,
    }
}

// POST /api/v1/divination/ask
func (dc *DivinationController) Ask(c *gin.Context) {
    var req DivinationRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, NewErrorResponse("INVALID_INPUT", err.Error()))
        return
    }

    userID := GetUserIDFromContext(c)

    // æ£€æŸ¥ç”¨æˆ·æƒé™ (å…è´¹ç”¨æˆ·é™åˆ¶)
    if !dc.divinationService.CanUserAsk(userID) {
        c.JSON(http.StatusForbidden, NewErrorResponse("LIMIT_EXCEEDED", "Daily divination limit reached"))
        return
    }

    // è°ƒç”¨ AI æœåŠ¡ç”Ÿæˆå åœ
    result, err := dc.aiService.GenerateDivination(req.Question, req.Type, userID)
    if err != nil {
        dc.logger.WithError(err).Error("Failed to generate divination")
        c.JSON(http.StatusInternalServerError, NewErrorResponse("AI_ERROR", "Failed to generate divination"))
        return
    }

    // ä¿å­˜å åœç»“æœ
    divination, err := dc.divinationService.SaveDivination(userID, req, result)
    if err != nil {
        dc.logger.WithError(err).Error("Failed to save divination")
        c.JSON(http.StatusInternalServerError, NewErrorResponse("SAVE_ERROR", "Failed to save divination"))
        return
    }

    c.JSON(http.StatusOK, NewSuccessResponse("Divination generated successfully", divination))
}
```

---

## ğŸ—„ï¸ æ•°æ®æ¨¡å‹è®¾è®¡

### 1. **ç”¨æˆ·ç›¸å…³è¡¨ç»“æ„**

```sql
-- ç”¨æˆ·åŸºç¡€ä¿¡æ¯è¡¨
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255),
    avatar_url VARCHAR(500),
    birth_date DATE,
    timezone VARCHAR(50) DEFAULT 'UTC',
    subscription_type VARCHAR(20) DEFAULT 'free', -- free, premium
    subscription_expires_at TIMESTAMP,
    oauth_provider VARCHAR(20), -- google, apple, null
    oauth_user_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL
);

-- ç”¨æˆ·è®¾ç½®è¡¨
CREATE TABLE user_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    notification_enabled BOOLEAN DEFAULT true,
    daily_reminder_time TIME DEFAULT '09:00:00',
    language VARCHAR(10) DEFAULT 'zh-CN',
    theme VARCHAR(20) DEFAULT 'auto', -- light, dark, auto
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·ä¼šè¯è¡¨
CREATE TABLE user_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token_hash VARCHAR(255) NOT NULL,
    device_id VARCHAR(255),
    device_type VARCHAR(50), -- ios, android, web
    ip_address INET,
    user_agent TEXT,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 2. **å åœç›¸å…³è¡¨ç»“æ„**

```sql
-- å åœè®°å½•è¡¨
CREATE TABLE divinations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    question TEXT NOT NULL,
    divination_type VARCHAR(50) NOT NULL, -- tarot, astrology, iching, oracle
    cards_drawn JSONB, -- æŠ½å–çš„å¡ç‰‡ä¿¡æ¯
    ai_response JSONB NOT NULL, -- AI ç”Ÿæˆçš„è§£è¯»å†…å®¹
    feedback_rating INTEGER CHECK (feedback_rating >= 1 AND feedback_rating <= 5),
    feedback_comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_divinations_user_created (user_id, created_at),
    INDEX idx_divinations_type (divination_type)
);

-- å åœç±»å‹é…ç½®è¡¨
CREATE TABLE divination_types (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    card_deck JSONB, -- å¡ç‰Œæ•°æ®
    prompt_template TEXT NOT NULL,
    is_premium BOOLEAN DEFAULT false,
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ¯æ—¥è¿åŠ¿è¡¨
CREATE TABLE daily_fortunes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    fortune_date DATE NOT NULL,
    content JSONB NOT NULL, -- AI ç”Ÿæˆçš„è¿åŠ¿å†…å®¹
    is_read BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    UNIQUE(user_id, fortune_date)
);
```

### 3. **æƒ…ç»ªè¿½è¸ªè¡¨ç»“æ„**

```sql
-- æƒ…ç»ªè®°å½•è¡¨
CREATE TABLE emotions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    emotion_value INTEGER NOT NULL CHECK (emotion_value >= 1 AND emotion_value <= 10),
    emotion_labels TEXT[], -- ['happy', 'excited', 'grateful']
    notes TEXT,
    triggers TEXT[], -- æƒ…ç»ªè§¦å‘å› ç´ 
    recorded_at TIMESTAMP NOT NULL,
    ai_analysis JSONB, -- AI åˆ†æç»“æœ
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_emotions_user_recorded (user_id, recorded_at),
    INDEX idx_emotions_value (emotion_value)
);

-- æƒ…ç»ªåˆ†ææŠ¥å‘Šè¡¨
CREATE TABLE emotion_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    report_type VARCHAR(20) NOT NULL, -- weekly, monthly, yearly
    period_start DATE NOT NULL,
    period_end DATE NOT NULL,
    statistics JSONB NOT NULL, -- ç»Ÿè®¡æ•°æ®
    insights JSONB, -- AI æ´å¯Ÿ
    recommendations JSONB, -- å»ºè®®
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_emotion_reports_user_period (user_id, period_start, period_end)
);
```

### 4. **å†¥æƒ³ç›¸å…³è¡¨ç»“æ„**

```sql
-- å†¥æƒ³è¯¾ç¨‹è¡¨
CREATE TABLE meditation_courses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(200) NOT NULL,
    description TEXT,
    category VARCHAR(100), -- sleep, focus, anxiety, self-love
    duration_minutes INTEGER NOT NULL,
    audio_url VARCHAR(500) NOT NULL,
    transcript TEXT,
    background_music_url VARCHAR(500),
    breathing_pattern JSONB, -- å‘¼å¸èŠ‚å¥æ•°æ®
    difficulty_level INTEGER DEFAULT 1 CHECK (difficulty_level >= 1 AND difficulty_level <= 3),
    is_premium BOOLEAN DEFAULT false,
    tags TEXT[],
    sort_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å†¥æƒ³ä¼šè¯è®°å½•è¡¨
CREATE TABLE meditation_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    course_id UUID REFERENCES meditation_courses(id),
    started_at TIMESTAMP NOT NULL,
    completed_at TIMESTAMP,
    duration_seconds INTEGER,
    completion_percentage INTEGER DEFAULT 0,
    session_data JSONB, -- ä¼šè¯è¿‡ç¨‹æ•°æ®
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_meditation_sessions_user (user_id, started_at),
    INDEX idx_meditation_sessions_course (course_id)
);

-- å†¥æƒ³æŒ‘æˆ˜è¡¨
CREATE TABLE meditation_challenges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    challenge_type VARCHAR(50) NOT NULL, -- 7_day, 21_day, 30_day
    started_at TIMESTAMP NOT NULL,
    target_days INTEGER NOT NULL,
    completed_days INTEGER DEFAULT 0,
    is_completed BOOLEAN DEFAULT false,
    completed_at TIMESTAMP,
    streak_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 5. **Go æ•°æ®æ¨¡å‹ç»“æ„**

```go
// models/user.go
type User struct {
    ID                   uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    Email                string     `json:"email" gorm:"uniqueIndex;not null" validate:"required,email"`
    Username             string     `json:"username" gorm:"uniqueIndex;not null" validate:"required,min=3,max=50"`
    PasswordHash         string     `json:"-" gorm:"column:password_hash"`
    AvatarURL            *string    `json:"avatar_url,omitempty"`
    BirthDate            *time.Time `json:"birth_date,omitempty"`
    Timezone             string     `json:"timezone" gorm:"default:UTC"`
    SubscriptionType     string     `json:"subscription_type" gorm:"default:free" validate:"oneof=free premium"`
    SubscriptionExpiresAt *time.Time `json:"subscription_expires_at,omitempty"`
    OAuthProvider        *string    `json:"oauth_provider,omitempty" validate:"omitempty,oneof=google apple"`
    OAuthUserID          *string    `json:"-" gorm:"column:oauth_user_id"`
    CreatedAt            time.Time  `json:"created_at"`
    UpdatedAt            time.Time  `json:"updated_at"`
    DeletedAt            *time.Time `json:"-" gorm:"index"`

    // å…³è”å…³ç³»
    Settings             UserSettings    `json:"settings,omitempty" gorm:"foreignKey:UserID"`
    Divinations         []Divination    `json:"-" gorm:"foreignKey:UserID"`
    Emotions            []Emotion       `json:"-" gorm:"foreignKey:UserID"`
    MeditationSessions  []MeditationSession `json:"-" gorm:"foreignKey:UserID"`
}

// models/divination.go
type Divination struct {
    ID               uuid.UUID       `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    UserID           uuid.UUID       `json:"user_id" gorm:"type:uuid;not null"`
    Question         string          `json:"question" gorm:"not null" validate:"required,max=500"`
    DivinationType   string          `json:"divination_type" gorm:"not null" validate:"required,oneof=tarot astrology iching oracle"`
    CardsDrawn       datatypes.JSON  `json:"cards_drawn,omitempty"`
    AIResponse       datatypes.JSON  `json:"ai_response" gorm:"not null"`
    FeedbackRating   *int           `json:"feedback_rating,omitempty" validate:"omitempty,min=1,max=5"`
    FeedbackComment  *string        `json:"feedback_comment,omitempty"`
    CreatedAt        time.Time      `json:"created_at"`

    // å…³è”å…³ç³»
    User User `json:"user,omitempty" gorm:"foreignKey:UserID"`
}

// DivinationResponse AI å“åº”ç»“æ„
type DivinationResponse struct {
    Interpretation string `json:"interpretation"`
    Advice        string `json:"advice"`
    Keywords      []string `json:"keywords"`
    Mood          string `json:"mood"`
    LuckyColor    string `json:"lucky_color,omitempty"`
    LuckyNumber   int    `json:"lucky_number,omitempty"`
}
```

---

## ğŸ”§ ä¸­é—´ä»¶è®¾è®¡

### 1. **JWT è®¤è¯ä¸­é—´ä»¶**

```go
// middleware/auth.go
func JWTAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := extractToken(c)
        if token == "" {
            c.JSON(http.StatusUnauthorized, NewErrorResponse("AUTH_REQUIRED", "Authentication required"))
            c.Abort()
            return
        }

        claims, err := ValidateJWT(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, NewErrorResponse("INVALID_TOKEN", err.Error()))
            c.Abort()
            return
        }

        // æ£€æŸ¥ä¼šè¯æ˜¯å¦æœ‰æ•ˆ
        session, err := sessionService.GetSession(claims.SessionID)
        if err != nil || session.ExpiresAt.Before(time.Now()) {
            c.JSON(http.StatusUnauthorized, NewErrorResponse("SESSION_EXPIRED", "Session expired"))
            c.Abort()
            return
        }

        // è®¾ç½®ç”¨æˆ·ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
        c.Set("user_id", claims.UserID)
        c.Set("session_id", claims.SessionID)
        c.Set("subscription_type", claims.SubscriptionType)

        c.Next()
    }
}

func extractToken(c *gin.Context) string {
    // ä» Header è·å–
    bearerToken := c.GetHeader("Authorization")
    if len(bearerToken) > 7 && bearerToken[:7] == "Bearer " {
        return bearerToken[7:]
    }

    // ä» Cookie è·å–
    token, _ := c.Cookie("auth_token")
    return token
}
```

### 2. **é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶**

```go
// middleware/ratelimit.go
type RateLimiter struct {
    redis  *redis.Client
    config RateLimitConfig
}

type RateLimitConfig struct {
    Requests     int           // è¯·æ±‚æ•°é‡
    Window       time.Duration // æ—¶é—´çª—å£
    KeyGenerator func(*gin.Context) string
}

func NewRateLimiter(redis *redis.Client, config RateLimitConfig) *RateLimiter {
    return &RateLimiter{
        redis:  redis,
        config: config,
    }
}

func (rl *RateLimiter) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        key := rl.config.KeyGenerator(c)

        // ä½¿ç”¨æ»‘åŠ¨çª—å£ç®—æ³•
        now := time.Now().Unix()
        windowStart := now - int64(rl.config.Window.Seconds())

        pipe := rl.redis.Pipeline()

        // åˆ é™¤çª—å£å¤–çš„è®°å½•
        pipe.ZRemRangeByScore(c, key, "0", fmt.Sprintf("%d", windowStart))

        // æ·»åŠ å½“å‰è¯·æ±‚
        pipe.ZAdd(c, key, &redis.Z{Score: float64(now), Member: now})

        // è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
        pipe.ZCard(c, key)

        // è®¾ç½®è¿‡æœŸæ—¶é—´
        pipe.Expire(c, key, rl.config.Window)

        results, err := pipe.Exec(c)
        if err != nil {
            c.JSON(http.StatusInternalServerError, NewErrorResponse("RATE_LIMIT_ERROR", "Rate limit check failed"))
            c.Abort()
            return
        }

        requestCount := results[2].(*redis.IntCmd).Val()

        if requestCount > int64(rl.config.Requests) {
            c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", rl.config.Requests))
            c.Header("X-RateLimit-Remaining", "0")
            c.Header("X-RateLimit-Reset", fmt.Sprintf("%d", now+int64(rl.config.Window.Seconds())))

            c.JSON(http.StatusTooManyRequests, NewErrorResponse("RATE_LIMIT_EXCEEDED", "Too many requests"))
            c.Abort()
            return
        }

        c.Header("X-RateLimit-Limit", fmt.Sprintf("%d", rl.config.Requests))
        c.Header("X-RateLimit-Remaining", fmt.Sprintf("%d", rl.config.Requests-int(requestCount)))

        c.Next()
    }
}

// ä¸åŒæ¥å£çš„é™æµé…ç½®
func SetupRateLimiting(r *gin.Engine, redis *redis.Client) {
    // é€šç”¨ API é™æµ (æ¯åˆ†é’Ÿ 60 è¯·æ±‚)
    generalLimiter := NewRateLimiter(redis, RateLimitConfig{
        Requests: 60,
        Window:   time.Minute,
        KeyGenerator: func(c *gin.Context) string {
            userID := GetUserIDFromContext(c)
            return fmt.Sprintf("rate_limit:general:%s", userID)
        },
    })

    // AI æ¥å£é™æµ (æ¯åˆ†é’Ÿ 10 è¯·æ±‚)
    aiLimiter := NewRateLimiter(redis, RateLimitConfig{
        Requests: 10,
        Window:   time.Minute,
        KeyGenerator: func(c *gin.Context) string {
            userID := GetUserIDFromContext(c)
            return fmt.Sprintf("rate_limit:ai:%s", userID)
        },
    })

    r.Use(generalLimiter.Middleware())

    // AI ç›¸å…³æ¥å£ä½¿ç”¨æ›´ä¸¥æ ¼çš„é™æµ
    api := r.Group("/api/v1")
    api.Use(aiLimiter.Middleware())
    {
        api.POST("/divination/ask", divinationController.Ask)
        api.POST("/journal/*/analyze", journalController.AnalyzeEntry)
    }
}
```

### 3. **æ—¥å¿—è®°å½•ä¸­é—´ä»¶**

```go
// middleware/logging.go
func RequestLogger(logger *logrus.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        startTime := time.Now()

        // ç”Ÿæˆè¯·æ±‚ ID
        requestID := uuid.New().String()
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)

        // è®°å½•è¯·æ±‚å¼€å§‹
        logger.WithFields(logrus.Fields{
            "request_id": requestID,
            "method":     c.Request.Method,
            "path":       c.Request.URL.Path,
            "query":      c.Request.URL.RawQuery,
            "ip":         c.ClientIP(),
            "user_agent": c.Request.UserAgent(),
        }).Info("Request started")

        c.Next()

        // è®°å½•è¯·æ±‚ç»“æŸ
        duration := time.Since(startTime)
        status := c.Writer.Status()

        logEntry := logger.WithFields(logrus.Fields{
            "request_id": requestID,
            "status":     status,
            "duration":   duration.Milliseconds(),
            "size":       c.Writer.Size(),
        })

        if status >= 500 {
            logEntry.Error("Request completed with server error")
        } else if status >= 400 {
            logEntry.Warn("Request completed with client error")
        } else {
            logEntry.Info("Request completed successfully")
        }
    }
}
```

### 4. **CORS ä¸­é—´ä»¶**

```go
// middleware/cors.go
func CORS() gin.HandlerFunc {
    return cors.New(cors.Config{
        AllowOrigins: []string{
            "http://localhost:3000",
            "https://app.oraura.com",
            "https://admin.oraura.com",
        },
        AllowMethods: []string{
            "GET", "POST", "PUT", "DELETE", "OPTIONS",
        },
        AllowHeaders: []string{
            "Origin", "Content-Type", "Authorization", "Accept",
            "X-Requested-With", "X-Request-ID",
        },
        ExposeHeaders: []string{
            "X-Request-ID", "X-RateLimit-Limit", "X-RateLimit-Remaining",
        },
        AllowCredentials: true,
        MaxAge:          12 * time.Hour,
    })
}
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•ç­–ç•¥

### 1. **æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡**

- **æ•´ä½“è¦†ç›–ç‡**: > 85%
- **æ ¸å¿ƒä¸šåŠ¡é€»è¾‘**: > 95%
- **API æ¥å£**: > 90%
- **æ•°æ®åº“æ“ä½œ**: > 90%

### 2. **æµ‹è¯•æ¡†æ¶é€‰æ‹©**

```go
// ä½¿ç”¨çš„æµ‹è¯•åº“
// go.mod
require (
    github.com/stretchr/testify v1.8.4
    github.com/gin-gonic/gin v1.9.1
    github.com/golang/mock v1.6.0
    github.com/DATA-DOG/go-sqlmock v1.5.0
    github.com/go-redis/redismock/v9 v9.0.2
)
```

### 3. **æ§åˆ¶å™¨æµ‹è¯•ç¤ºä¾‹**

```go
// controllers/divination_controller_test.go
package controllers

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
    "github.com/golang/mock/gomock"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
)

type DivinationControllerTestSuite struct {
    suite.Suite
    controller       *DivinationController
    mockService      *MockDivinationService
    mockAIService    *MockAIService
    router          *gin.Engine
    ctrl            *gomock.Controller
}

func (suite *DivinationControllerTestSuite) SetupTest() {
    gin.SetMode(gin.TestMode)

    suite.ctrl = gomock.NewController(suite.T())
    suite.mockService = NewMockDivinationService(suite.ctrl)
    suite.mockAIService = NewMockAIService(suite.ctrl)

    suite.controller = NewDivinationController(
        suite.mockService,
        suite.mockAIService,
        logrus.New(),
    )

    suite.router = gin.New()
    suite.router.POST("/divination/ask", suite.controller.Ask)
}

func (suite *DivinationControllerTestSuite) TearDownTest() {
    suite.ctrl.Finish()
}

func (suite *DivinationControllerTestSuite) TestAsk_Success() {
    // å‡†å¤‡æµ‹è¯•æ•°æ®
    userID := uuid.New()
    request := DivinationRequest{
        Question: "What should I focus on today?",
        Type:     "tarot",
    }

    expectedResponse := &DivinationResponse{
        Interpretation: "Focus on inner wisdom",
        Advice:        "Trust your intuition",
        Keywords:      []string{"wisdom", "intuition"},
        Mood:          "contemplative",
    }

    expectedDivination := &Divination{
        ID:             uuid.New(),
        UserID:         userID,
        Question:       request.Question,
        DivinationType: request.Type,
        AIResponse:     datatypes.JSON(expectedResponse),
    }

    // è®¾ç½® Mock æœŸæœ›
    suite.mockService.EXPECT().
        CanUserAsk(userID).
        Return(true)

    suite.mockAIService.EXPECT().
        GenerateDivination(request.Question, request.Type, userID).
        Return(expectedResponse, nil)

    suite.mockService.EXPECT().
        SaveDivination(userID, request, expectedResponse).
        Return(expectedDivination, nil)

    // å‡†å¤‡è¯·æ±‚
    jsonData, _ := json.Marshal(request)
    req := httptest.NewRequest("POST", "/divination/ask", bytes.NewBuffer(jsonData))
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()

    // æ¨¡æ‹Ÿè®¤è¯ç”¨æˆ·
    c, _ := gin.CreateTestContext(w)
    c.Request = req
    c.Set("user_id", userID)

    // æ‰§è¡Œè¯·æ±‚
    suite.controller.Ask(c)

    // éªŒè¯ç»“æœ
    assert.Equal(suite.T(), http.StatusOK, w.Code)

    var response APIResponse
    err := json.Unmarshal(w.Body.Bytes(), &response)
    assert.NoError(suite.T(), err)
    assert.True(suite.T(), response.Success)
    assert.NotNil(suite.T(), response.Data)
}

func (suite *DivinationControllerTestSuite) TestAsk_LimitExceeded() {
    userID := uuid.New()

    suite.mockService.EXPECT().
        CanUserAsk(userID).
        Return(false)

    request := DivinationRequest{
        Question: "Test question",
        Type:     "tarot",
    }

    jsonData, _ := json.Marshal(request)
    req := httptest.NewRequest("POST", "/divination/ask", bytes.NewBuffer(jsonData))
    req.Header.Set("Content-Type", "application/json")

    w := httptest.NewRecorder()
    c, _ := gin.CreateTestContext(w)
    c.Request = req
    c.Set("user_id", userID)

    suite.controller.Ask(c)

    assert.Equal(suite.T(), http.StatusForbidden, w.Code)
}

func TestDivinationControllerTestSuite(t *testing.T) {
    suite.Run(t, new(DivinationControllerTestSuite))
}
```

### 4. **æœåŠ¡å±‚æµ‹è¯•ç¤ºä¾‹**

```go
// services/divination_service_test.go
package services

import (
    "testing"
    "time"

    "github.com/DATA-DOG/go-sqlmock"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/suite"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

type DivinationServiceTestSuite struct {
    suite.Suite
    service *DivinationService
    db      *gorm.DB
    mock    sqlmock.Sqlmock
}

func (suite *DivinationServiceTestSuite) SetupTest() {
    db, mock, err := sqlmock.New()
    assert.NoError(suite.T(), err)

    gormDB, err := gorm.Open(postgres.New(postgres.Config{
        Conn: db,
    }), &gorm.Config{})
    assert.NoError(suite.T(), err)

    suite.db = gormDB
    suite.mock = mock
    suite.service = NewDivinationService(gormDB)
}

func (suite *DivinationServiceTestSuite) TestCanUserAsk_FreeUserWithinLimit() {
    userID := uuid.New()
    today := time.Now().Truncate(24 * time.Hour)

    // Mock æŸ¥è¯¢ä»Šæ—¥å åœæ¬¡æ•°
    rows := sqlmock.NewRows([]string{"count"}).AddRow(0)
    suite.mock.ExpectQuery(`SELECT count\(\*\) FROM "divinations"`).
        WithArgs(userID, today, today.Add(24*time.Hour)).
        WillReturnRows(rows)

    // Mock æŸ¥è¯¢ç”¨æˆ·è®¢é˜…çŠ¶æ€
    userRows := sqlmock.NewRows([]string{"subscription_type"}).AddRow("free")
    suite.mock.ExpectQuery(`SELECT.*FROM "users"`).
        WithArgs(userID).
        WillReturnRows(userRows)

    result := suite.service.CanUserAsk(userID)

    assert.True(suite.T(), result)
    assert.NoError(suite.T(), suite.mock.ExpectationsWereMet())
}

func (suite *DivinationServiceTestSuite) TestSaveDivination_Success() {
    userID := uuid.New()
    request := DivinationRequest{
        Question: "Test question",
        Type:     "tarot",
    }
    response := &DivinationResponse{
        Interpretation: "Test interpretation",
    }

    // Mock INSERT æ“ä½œ
    suite.mock.ExpectBegin()
    suite.mock.ExpectQuery(`INSERT INTO "divinations"`).
        WithArgs(
            sqlmock.AnyArg(), // id
            userID,
            request.Question,
            request.Type,
            sqlmock.AnyArg(), // cards_drawn
            sqlmock.AnyArg(), // ai_response
            sqlmock.AnyArg(), // created_at
        ).
        WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(uuid.New()))
    suite.mock.ExpectCommit()

    result, err := suite.service.SaveDivination(userID, request, response)

    assert.NoError(suite.T(), err)
    assert.NotNil(suite.T(), result)
    assert.Equal(suite.T(), userID, result.UserID)
    assert.Equal(suite.T(), request.Question, result.Question)
    assert.NoError(suite.T(), suite.mock.ExpectationsWereMet())
}

func TestDivinationServiceTestSuite(t *testing.T) {
    suite.Run(t, new(DivinationServiceTestSuite))
}
```

### 5. **é›†æˆæµ‹è¯•é…ç½®**

```go
// tests/integration/setup.go
package integration

import (
    "fmt"
    "testing"

    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/modules/postgres"
    "github.com/testcontainers/testcontainers-go/modules/redis"
)

type TestEnvironment struct {
    PostgresContainer testcontainers.Container
    RedisContainer    testcontainers.Container
    DB               *gorm.DB
    Redis            *redis.Client
}

func SetupTestEnvironment(t *testing.T) *TestEnvironment {
    ctx := context.Background()

    // å¯åŠ¨ PostgreSQL å®¹å™¨
    pgContainer, err := postgres.RunContainer(ctx,
        testcontainers.WithImage("postgres:15"),
        postgres.WithDatabase("oraura_test"),
        postgres.WithUsername("test"),
        postgres.WithPassword("test"),
    )
    require.NoError(t, err)

    // å¯åŠ¨ Redis å®¹å™¨
    redisContainer, err := redis.RunContainer(ctx,
        testcontainers.WithImage("redis:7"),
    )
    require.NoError(t, err)

    // è·å–è¿æ¥ä¿¡æ¯
    pgHost, _ := pgContainer.Host(ctx)
    pgPort, _ := pgContainer.MappedPort(ctx, "5432")

    redisHost, _ := redisContainer.Host(ctx)
    redisPort, _ := redisContainer.MappedPort(ctx, "6379")

    // è¿æ¥æ•°æ®åº“
    dsn := fmt.Sprintf("host=%s port=%s user=test password=test dbname=oraura_test sslmode=disable",
        pgHost, pgPort.Port())
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    require.NoError(t, err)

    // è¿æ¥ Redis
    rdb := redis.NewClient(&redis.Options{
        Addr: fmt.Sprintf("%s:%s", redisHost, redisPort.Port()),
    })

    // è¿è¡Œæ•°æ®åº“è¿ç§»
    err = db.AutoMigrate(&User{}, &Divination{}, &Emotion{}, &MeditationCourse{})
    require.NoError(t, err)

    return &TestEnvironment{
        PostgresContainer: pgContainer,
        RedisContainer:    redisContainer,
        DB:               db,
        Redis:            rdb,
    }
}

func (env *TestEnvironment) Cleanup() {
    env.PostgresContainer.Terminate(context.Background())
    env.RedisContainer.Terminate(context.Background())
}
```

### 6. **æ€§èƒ½æµ‹è¯•**

```go
// tests/performance/api_test.go
package performance

import (
    "testing"
    "time"

    "github.com/go-resty/resty/v2"
    "github.com/stretchr/testify/assert"
)

func BenchmarkDivinationAPI(b *testing.B) {
    client := resty.New()

    // ç™»å½•è·å– token
    token := getTestToken(client)
    client.SetAuthToken(token)

    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            resp, err := client.R().
                SetBody(map[string]interface{}{
                    "question": "What should I focus on today?",
                    "type":     "tarot",
                }).
                Post("http://localhost:8080/api/v1/divination/ask")

            assert.NoError(b, err)
            assert.Equal(b, 200, resp.StatusCode())
        }
    })
}

func TestAPIResponseTime(t *testing.T) {
    client := resty.New()
    token := getTestToken(client)
    client.SetAuthToken(token)

    start := time.Now()
    resp, err := client.R().
        SetBody(map[string]interface{}{
            "question": "Test question",
            "type":     "tarot",
        }).
        Post("http://localhost:8080/api/v1/divination/ask")

    duration := time.Since(start)

    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode())
    assert.Less(t, duration, 5*time.Second, "API response should be under 5 seconds")
}
```

### 7. **æµ‹è¯•è¿è¡Œè„šæœ¬**

```makefile
# Makefile
.PHONY: test test-unit test-integration test-performance test-coverage

# è¿è¡Œæ‰€æœ‰æµ‹è¯•
test: test-unit test-integration

# å•å…ƒæµ‹è¯•
test-unit:
	go test -v -race ./controllers/... ./services/... ./models/...

# é›†æˆæµ‹è¯•
test-integration:
	go test -v -tags=integration ./tests/integration/...

# æ€§èƒ½æµ‹è¯•
test-performance:
	go test -v -bench=. -benchmem ./tests/performance/...

# æµ‹è¯•è¦†ç›–ç‡
test-coverage:
	go test -v -race -coverprofile=coverage.out ./...
	go tool cover -html=coverage.out -o coverage.html
	go tool cover -func=coverage.out | grep total | awk '{print $$3}'

# ç”Ÿæˆ Mock
generate-mocks:
	mockgen -source=services/divination_service.go -destination=mocks/mock_divination_service.go
	mockgen -source=services/ai_service.go -destination=mocks/mock_ai_service.go
	mockgen -source=services/user_service.go -destination=mocks/mock_user_service.go

# æ¸…ç†æµ‹è¯•æ•°æ®
clean-test:
	docker-compose -f docker-compose.test.yml down -v
```

è¿™ä¸ªåç«¯æ¨¡å—è®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ Go + Gin åç«¯æ¶æ„ï¼ŒåŒ…æ‹¬è¯¦ç»†çš„ API è®¾è®¡ã€æ•°æ®æ¨¡å‹ã€ä¸­é—´ä»¶å’Œå…¨é¢çš„æµ‹è¯•ç­–ç•¥ã€‚æ¥ä¸‹æ¥æˆ‘å°†ç»§ç»­åˆ›å»ºå‰ç«¯æ¨¡å—è®¾è®¡æ–‡æ¡£ã€‚
