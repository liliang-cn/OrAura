# OrAura å®‰å…¨ä¸åˆè§„è®¾è®¡æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° OrAura é¡¹ç›®çš„å®‰å…¨æ¶æ„è®¾è®¡å’Œåˆè§„è¦æ±‚ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€æ•°æ®åŠ å¯†ã€éšç§ä¿æŠ¤ã€OAuth2 æµç¨‹ã€å®‰å…¨ç›‘æ§å’Œç›¸å…³æ³•è§„åˆè§„ç­–ç•¥ã€‚

---

## ğŸ” èº«ä»½è®¤è¯ä¸æˆæƒæ¶æ„

### 1. **JWT è®¤è¯æœºåˆ¶è®¾è®¡**

```go
// pkg/auth/jwt.go
package auth

import (
    "time"
    "crypto/rsa"
    "github.com/golang-jwt/jwt/v5"
)

type JWTManager struct {
    privateKey *rsa.PrivateKey
    publicKey  *rsa.PublicKey
    issuer     string
    expiry     time.Duration
}

type Claims struct {
    UserID           string   `json:"user_id"`
    Email            string   `json:"email"`
    SubscriptionType string   `json:"subscription_type"`
    Roles            []string `json:"roles"`
    SessionID        string   `json:"session_id"`
    DeviceID         string   `json:"device_id,omitempty"`
    jwt.RegisteredClaims
}

type RefreshTokenClaims struct {
    UserID    string `json:"user_id"`
    SessionID string `json:"session_id"`
    TokenType string `json:"token_type"` // "refresh"
    jwt.RegisteredClaims
}

func NewJWTManager(privateKeyPath, publicKeyPath string) (*JWTManager, error) {
    privateKey, err := loadRSAPrivateKey(privateKeyPath)
    if err != nil {
        return nil, err
    }

    publicKey, err := loadRSAPublicKey(publicKeyPath)
    if err != nil {
        return nil, err
    }

    return &JWTManager{
        privateKey: privateKey,
        publicKey:  publicKey,
        issuer:     "oraura-api",
        expiry:     time.Hour * 24, // 24å°æ—¶è¿‡æœŸ
    }, nil
}

func (j *JWTManager) GenerateTokenPair(userID, email, subscriptionType string, roles []string, sessionID, deviceID string) (string, string, error) {
    now := time.Now()

    // Access Token (è¾ƒçŸ­è¿‡æœŸæ—¶é—´)
    accessClaims := &Claims{
        UserID:           userID,
        Email:            email,
        SubscriptionType: subscriptionType,
        Roles:            roles,
        SessionID:        sessionID,
        DeviceID:         deviceID,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    j.issuer,
            Subject:   userID,
            Audience:  jwt.ClaimStrings{"oraura-app"},
            ExpiresAt: jwt.NewNumericDate(now.Add(time.Hour)),
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        generateJTI(),
        },
    }

    accessToken := jwt.NewWithClaims(jwt.SigningMethodRS256, accessClaims)
    accessTokenString, err := accessToken.SignedString(j.privateKey)
    if err != nil {
        return "", "", err
    }

    // Refresh Token (è¾ƒé•¿è¿‡æœŸæ—¶é—´)
    refreshClaims := &RefreshTokenClaims{
        UserID:    userID,
        SessionID: sessionID,
        TokenType: "refresh",
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    j.issuer,
            Subject:   userID,
            Audience:  jwt.ClaimStrings{"oraura-refresh"},
            ExpiresAt: jwt.NewNumericDate(now.Add(time.Hour * 24 * 30)), // 30å¤©
            NotBefore: jwt.NewNumericDate(now),
            IssuedAt:  jwt.NewNumericDate(now),
            ID:        generateJTI(),
        },
    }

    refreshToken := jwt.NewWithClaims(jwt.SigningMethodRS256, refreshClaims)
    refreshTokenString, err := refreshToken.SignedString(j.privateKey)
    if err != nil {
        return "", "", err
    }

    return accessTokenString, refreshTokenString, nil
}

func (j *JWTManager) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return j.publicKey, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("invalid token")
}

// Token é»‘åå•ç®¡ç†
type TokenBlacklist struct {
    redis *redis.Client
}

func (tb *TokenBlacklist) AddToBlacklist(jti string, expiry time.Time) error {
    ttl := time.Until(expiry)
    if ttl <= 0 {
        return nil // å·²è¿‡æœŸçš„tokenæ— éœ€åŠ å…¥é»‘åå•
    }

    return tb.redis.Set(context.Background(), "blacklist:"+jti, "true", ttl).Err()
}

func (tb *TokenBlacklist) IsBlacklisted(jti string) (bool, error) {
    result, err := tb.redis.Exists(context.Background(), "blacklist:"+jti).Result()
    return result > 0, err
}
```

### 2. **ä¼šè¯ç®¡ç†ç³»ç»Ÿ**

```go
// pkg/auth/session.go
package auth

import (
    "time"
    "encoding/json"
    "github.com/google/uuid"
)

type Session struct {
    ID           string            `json:"id"`
    UserID       string            `json:"user_id"`
    DeviceID     string            `json:"device_id,omitempty"`
    DeviceType   string            `json:"device_type"` // ios, android, web
    IPAddress    string            `json:"ip_address"`
    UserAgent    string            `json:"user_agent"`
    Location     *GeoLocation      `json:"location,omitempty"`
    CreatedAt    time.Time         `json:"created_at"`
    LastUsedAt   time.Time         `json:"last_used_at"`
    ExpiresAt    time.Time         `json:"expires_at"`
    IsActive     bool              `json:"is_active"`
    Metadata     map[string]string `json:"metadata,omitempty"`
}

type GeoLocation struct {
    Country  string  `json:"country"`
    Region   string  `json:"region"`
    City     string  `json:"city"`
    Latitude float64 `json:"latitude"`
    Longitude float64 `json:"longitude"`
}

type SessionManager struct {
    redis          *redis.Client
    postgres       *gorm.DB
    maxSessions    int
    sessionExpiry  time.Duration
    cleanupInterval time.Duration
}

func NewSessionManager(redis *redis.Client, postgres *gorm.DB) *SessionManager {
    sm := &SessionManager{
        redis:          redis,
        postgres:       postgres,
        maxSessions:    5, // æ¯ç”¨æˆ·æœ€å¤š5ä¸ªæ´»è·ƒä¼šè¯
        sessionExpiry:  time.Hour * 24 * 30, // 30å¤©
        cleanupInterval: time.Hour * 6, // 6å°æ—¶æ¸…ç†ä¸€æ¬¡
    }

    // å¯åŠ¨å®šæœŸæ¸…ç†
    go sm.startCleanup()

    return sm
}

func (sm *SessionManager) CreateSession(userID, deviceID, deviceType, ipAddress, userAgent string, location *GeoLocation) (*Session, error) {
    // æ£€æŸ¥å¹¶æ¸…ç†è¶…å‡ºé™åˆ¶çš„ä¼šè¯
    if err := sm.enforceSessionLimit(userID); err != nil {
        return nil, err
    }

    session := &Session{
        ID:         uuid.New().String(),
        UserID:     userID,
        DeviceID:   deviceID,
        DeviceType: deviceType,
        IPAddress:  ipAddress,
        UserAgent:  userAgent,
        Location:   location,
        CreatedAt:  time.Now(),
        LastUsedAt: time.Now(),
        ExpiresAt:  time.Now().Add(sm.sessionExpiry),
        IsActive:   true,
        Metadata:   make(map[string]string),
    }

    // ä¿å­˜åˆ° Redis (å¿«é€Ÿè®¿é—®)
    sessionData, _ := json.Marshal(session)
    pipe := sm.redis.Pipeline()
    pipe.Set(context.Background(), "session:"+session.ID, sessionData, sm.sessionExpiry)
    pipe.SAdd(context.Background(), "user_sessions:"+userID, session.ID)
    pipe.Exec(context.Background())

    // ä¿å­˜åˆ° PostgreSQL (æŒä¹…åŒ–)
    if err := sm.postgres.Create(session).Error; err != nil {
        return nil, err
    }

    return session, nil
}

func (sm *SessionManager) GetSession(sessionID string) (*Session, error) {
    // ä¼˜å…ˆä» Redis è·å–
    sessionData, err := sm.redis.Get(context.Background(), "session:"+sessionID).Result()
    if err == nil {
        var session Session
        if err := json.Unmarshal([]byte(sessionData), &session); err == nil {
            return &session, nil
        }
    }

    // Redis ä¸­æ²¡æœ‰ï¼Œä»æ•°æ®åº“è·å–
    var session Session
    if err := sm.postgres.Where("id = ? AND is_active = ?", sessionID, true).First(&session).Error; err != nil {
        return nil, err
    }

    // é‡æ–°ç¼“å­˜åˆ° Redis
    sessionData, _ = json.Marshal(session)
    sm.redis.Set(context.Background(), "session:"+sessionID, sessionData, time.Until(session.ExpiresAt))

    return &session, nil
}

func (sm *SessionManager) UpdateLastUsed(sessionID string) error {
    now := time.Now()

    // æ›´æ–° Redis ç¼“å­˜
    sessionData, err := sm.redis.Get(context.Background(), "session:"+sessionID).Result()
    if err == nil {
        var session Session
        if err := json.Unmarshal([]byte(sessionData), &session); err == nil {
            session.LastUsedAt = now
            newSessionData, _ := json.Marshal(session)
            sm.redis.Set(context.Background(), "session:"+sessionID, newSessionData, time.Until(session.ExpiresAt))
        }
    }

    // å¼‚æ­¥æ›´æ–°æ•°æ®åº“
    go func() {
        sm.postgres.Model(&Session{}).Where("id = ?", sessionID).Update("last_used_at", now)
    }()

    return nil
}

func (sm *SessionManager) RevokeSession(sessionID string) error {
    session, err := sm.GetSession(sessionID)
    if err != nil {
        return err
    }

    // ä» Redis åˆ é™¤
    pipe := sm.redis.Pipeline()
    pipe.Del(context.Background(), "session:"+sessionID)
    pipe.SRem(context.Background(), "user_sessions:"+session.UserID, sessionID)
    pipe.Exec(context.Background())

    // æ ‡è®°ä¸ºéæ´»è·ƒ
    return sm.postgres.Model(&Session{}).Where("id = ?", sessionID).Update("is_active", false)
}

func (sm *SessionManager) RevokeAllUserSessions(userID string) error {
    sessionIDs, err := sm.redis.SMembers(context.Background(), "user_sessions:"+userID).Result()
    if err != nil {
        return err
    }

    // æ‰¹é‡åˆ é™¤ Redis ä¼šè¯
    if len(sessionIDs) > 0 {
        keys := make([]string, len(sessionIDs))
        for i, id := range sessionIDs {
            keys[i] = "session:" + id
        }

        pipe := sm.redis.Pipeline()
        pipe.Del(context.Background(), keys...)
        pipe.Del(context.Background(), "user_sessions:"+userID)
        pipe.Exec(context.Background())
    }

    // æ ‡è®°æ•°æ®åº“ä¸­çš„ä¼šè¯ä¸ºéæ´»è·ƒ
    return sm.postgres.Model(&Session{}).Where("user_id = ? AND is_active = ?", userID, true).Update("is_active", false)
}

func (sm *SessionManager) enforceSessionLimit(userID string) error {
    sessionIDs, err := sm.redis.SMembers(context.Background(), "user_sessions:"+userID).Result()
    if err != nil {
        return err
    }

    if len(sessionIDs) >= sm.maxSessions {
        // è·å–æ‰€æœ‰ä¼šè¯è¯¦æƒ…
        sessions := make([]*Session, 0, len(sessionIDs))
        for _, id := range sessionIDs {
            if session, err := sm.GetSession(id); err == nil {
                sessions = append(sessions, session)
            }
        }

        // æŒ‰æœ€åä½¿ç”¨æ—¶é—´æ’åºï¼Œç§»é™¤æœ€æ—§çš„ä¼šè¯
        sort.Slice(sessions, func(i, j int) bool {
            return sessions[i].LastUsedAt.Before(sessions[j].LastUsedAt)
        })

        toRemove := len(sessions) - sm.maxSessions + 1
        for i := 0; i < toRemove; i++ {
            sm.RevokeSession(sessions[i].ID)
        }
    }

    return nil
}
```

---

## ğŸ”’ OAuth2 é›†æˆè®¾è®¡

### 1. **Google OAuth2 æµç¨‹**

```go
// pkg/auth/oauth_google.go
package auth

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "golang.org/x/oauth2"
    "golang.org/x/oauth2/google"
)

type GoogleOAuthConfig struct {
    ClientID     string
    ClientSecret string
    RedirectURL  string
    Scopes       []string
}

type GoogleUserInfo struct {
    ID            string `json:"id"`
    Email         string `json:"email"`
    VerifiedEmail bool   `json:"verified_email"`
    Name          string `json:"name"`
    GivenName     string `json:"given_name"`
    FamilyName    string `json:"family_name"`
    Picture       string `json:"picture"`
    Locale        string `json:"locale"`
}

type GoogleOAuthService struct {
    config       *oauth2.Config
    userService  UserService
    sessionMgr   *SessionManager
    jwtManager   *JWTManager
}

func NewGoogleOAuthService(cfg GoogleOAuthConfig, userService UserService, sessionMgr *SessionManager, jwtManager *JWTManager) *GoogleOAuthService {
    config := &oauth2.Config{
        ClientID:     cfg.ClientID,
        ClientSecret: cfg.ClientSecret,
        RedirectURL:  cfg.RedirectURL,
        Scopes:       cfg.Scopes,
        Endpoint:     google.Endpoint,
    }

    return &GoogleOAuthService{
        config:      config,
        userService: userService,
        sessionMgr:  sessionMgr,
        jwtManager:  jwtManager,
    }
}

func (g *GoogleOAuthService) GetAuthURL(state string) string {
    return g.config.AuthCodeURL(state, oauth2.AccessTypeOffline, oauth2.ApprovalForce)
}

func (g *GoogleOAuthService) HandleCallback(ctx context.Context, code, state string, clientInfo ClientInfo) (*AuthResponse, error) {
    // éªŒè¯ state å‚æ•°é˜²æ­¢ CSRF
    if !g.validateState(state) {
        return nil, fmt.Errorf("invalid state parameter")
    }

    // äº¤æ¢æˆæƒç è·å–è®¿é—®ä»¤ç‰Œ
    token, err := g.config.Exchange(ctx, code)
    if err != nil {
        return nil, fmt.Errorf("failed to exchange code: %w", err)
    }

    // è·å–ç”¨æˆ·ä¿¡æ¯
    userInfo, err := g.getUserInfo(ctx, token)
    if err != nil {
        return nil, fmt.Errorf("failed to get user info: %w", err)
    }

    // åˆ›å»ºæˆ–è·å–ç”¨æˆ·
    user, isNew, err := g.createOrGetUser(userInfo)
    if err != nil {
        return nil, fmt.Errorf("failed to create/get user: %w", err)
    }

    // åˆ›å»ºä¼šè¯
    session, err := g.sessionMgr.CreateSession(
        user.ID,
        clientInfo.DeviceID,
        clientInfo.DeviceType,
        clientInfo.IPAddress,
        clientInfo.UserAgent,
        clientInfo.Location,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create session: %w", err)
    }

    // ç”Ÿæˆ JWT ä»¤ç‰Œå¯¹
    accessToken, refreshToken, err := g.jwtManager.GenerateTokenPair(
        user.ID,
        user.Email,
        user.SubscriptionType,
        user.Roles,
        session.ID,
        clientInfo.DeviceID,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to generate tokens: %w", err)
    }

    return &AuthResponse{
        User:         user,
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        IsNewUser:    isNew,
    }, nil
}

func (g *GoogleOAuthService) getUserInfo(ctx context.Context, token *oauth2.Token) (*GoogleUserInfo, error) {
    client := g.config.Client(ctx, token)
    resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("failed to get user info: status %d", resp.StatusCode)
    }

    var userInfo GoogleUserInfo
    if err := json.NewDecoder(resp.Body).Decode(&userInfo); err != nil {
        return nil, err
    }

    return &userInfo, nil
}

func (g *GoogleOAuthService) createOrGetUser(googleUser *GoogleUserInfo) (*User, bool, error) {
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    user, err := g.userService.GetUserByEmail(googleUser.Email)
    if err == nil {
        // ç”¨æˆ·å·²å­˜åœ¨ï¼Œæ›´æ–° Google ç›¸å…³ä¿¡æ¯
        user.OAuthProvider = "google"
        user.OAuthUserID = googleUser.ID
        user.AvatarURL = &googleUser.Picture

        if err := g.userService.UpdateUser(user); err != nil {
            return nil, false, err
        }

        return user, false, nil
    }

    // åˆ›å»ºæ–°ç”¨æˆ·
    newUser := &User{
        Email:            googleUser.Email,
        Username:         generateUsernameFromEmail(googleUser.Email),
        OAuthProvider:    "google",
        OAuthUserID:      googleUser.ID,
        AvatarURL:        &googleUser.Picture,
        SubscriptionType: "free",
        Roles:           []string{"user"},
    }

    if err := g.userService.CreateUser(newUser); err != nil {
        return nil, false, err
    }

    return newUser, true, nil
}

func (g *GoogleOAuthService) validateState(state string) bool {
    // å®ç° state éªŒè¯é€»è¾‘ï¼Œé€šå¸¸å­˜å‚¨åœ¨ Redis ä¸­å¹¶è®¾ç½®è¿‡æœŸæ—¶é—´
    // è¿™é‡Œç®€åŒ–å¤„ç†
    return len(state) > 0
}
```

### 2. **Apple Sign In é›†æˆ**

```go
// pkg/auth/oauth_apple.go
package auth

import (
    "crypto/rsa"
    "time"
    "github.com/golang-jwt/jwt/v5"
)

type AppleOAuthConfig struct {
    TeamID      string
    ClientID    string
    KeyID       string
    PrivateKey  *rsa.PrivateKey
    RedirectURL string
}

type AppleOAuthService struct {
    config      AppleOAuthConfig
    userService UserService
    sessionMgr  *SessionManager
    jwtManager  *JWTManager
}

type AppleIDTokenClaims struct {
    Email         string `json:"email"`
    EmailVerified string `json:"email_verified"`
    IsPrivateEmail string `json:"is_private_email"`
    RealUserStatus int    `json:"real_user_status"`
    jwt.RegisteredClaims
}

func NewAppleOAuthService(cfg AppleOAuthConfig, userService UserService, sessionMgr *SessionManager, jwtManager *JWTManager) *AppleOAuthService {
    return &AppleOAuthService{
        config:      cfg,
        userService: userService,
        sessionMgr:  sessionMgr,
        jwtManager:  jwtManager,
    }
}

func (a *AppleOAuthService) HandleSignIn(idToken string, authorizationCode string, clientInfo ClientInfo) (*AuthResponse, error) {
    // éªŒè¯å’Œè§£æ ID Token
    claims, err := a.validateIDToken(idToken)
    if err != nil {
        return nil, fmt.Errorf("invalid ID token: %w", err)
    }

    // åˆ›å»ºæˆ–è·å–ç”¨æˆ·
    user, isNew, err := a.createOrGetUser(claims)
    if err != nil {
        return nil, fmt.Errorf("failed to create/get user: %w", err)
    }

    // åˆ›å»ºä¼šè¯
    session, err := a.sessionMgr.CreateSession(
        user.ID,
        clientInfo.DeviceID,
        clientInfo.DeviceType,
        clientInfo.IPAddress,
        clientInfo.UserAgent,
        clientInfo.Location,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create session: %w", err)
    }

    // ç”Ÿæˆ JWT ä»¤ç‰Œå¯¹
    accessToken, refreshToken, err := a.jwtManager.GenerateTokenPair(
        user.ID,
        user.Email,
        user.SubscriptionType,
        user.Roles,
        session.ID,
        clientInfo.DeviceID,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to generate tokens: %w", err)
    }

    return &AuthResponse{
        User:         user,
        AccessToken:  accessToken,
        RefreshToken: refreshToken,
        IsNewUser:    isNew,
    }, nil
}

func (a *AppleOAuthService) validateIDToken(idToken string) (*AppleIDTokenClaims, error) {
    // è·å– Apple çš„å…¬é’¥
    keySet, err := a.getApplePublicKeys()
    if err != nil {
        return nil, err
    }

    // è§£æ token
    token, err := jwt.ParseWithClaims(idToken, &AppleIDTokenClaims{}, func(token *jwt.Token) (interface{}, error) {
        kid, ok := token.Header["kid"].(string)
        if !ok {
            return nil, fmt.Errorf("missing kid in token header")
        }

        key, exists := keySet[kid]
        if !exists {
            return nil, fmt.Errorf("unknown key id: %s", kid)
        }

        return key, nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*AppleIDTokenClaims); ok && token.Valid {
        // éªŒè¯ audience
        if claims.Audience[0] != a.config.ClientID {
            return nil, fmt.Errorf("invalid audience")
        }

        // éªŒè¯ issuer
        if claims.Issuer != "https://appleid.apple.com" {
            return nil, fmt.Errorf("invalid issuer")
        }

        return claims, nil
    }

    return nil, fmt.Errorf("invalid token")
}

func (a *AppleOAuthService) createOrGetUser(appleClaims *AppleIDTokenClaims) (*User, bool, error) {
    email := appleClaims.Email

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    user, err := a.userService.GetUserByEmail(email)
    if err == nil {
        // ç”¨æˆ·å·²å­˜åœ¨ï¼Œæ›´æ–° Apple ç›¸å…³ä¿¡æ¯
        user.OAuthProvider = "apple"
        user.OAuthUserID = appleClaims.Subject

        if err := a.userService.UpdateUser(user); err != nil {
            return nil, false, err
        }

        return user, false, nil
    }

    // åˆ›å»ºæ–°ç”¨æˆ·
    newUser := &User{
        Email:            email,
        Username:         generateUsernameFromEmail(email),
        OAuthProvider:    "apple",
        OAuthUserID:      appleClaims.Subject,
        SubscriptionType: "free",
        Roles:           []string{"user"},
    }

    if err := a.userService.CreateUser(newUser); err != nil {
        return nil, false, err
    }

    return newUser, true, nil
}
```

---

## ğŸ›¡ï¸ æ•°æ®åŠ å¯†ä¸å­˜å‚¨å®‰å…¨

### 1. **æ•æ„Ÿæ•°æ®åŠ å¯†**

```go
// pkg/crypto/encryption.go
package crypto

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "errors"
    "io"
    "golang.org/x/crypto/pbkdf2"
)

type EncryptionService struct {
    masterKey []byte
}

func NewEncryptionService(masterKey string) *EncryptionService {
    // ä½¿ç”¨ PBKDF2 æ´¾ç”Ÿå¯†é’¥
    salt := []byte("oraura-salt-2024") // ç”Ÿäº§ç¯å¢ƒä¸­åº”ä½¿ç”¨éšæœºç›
    key := pbkdf2.Key([]byte(masterKey), salt, 100000, 32, sha256.New)

    return &EncryptionService{
        masterKey: key,
    }
}

func (e *EncryptionService) Encrypt(plaintext string) (string, error) {
    if plaintext == "" {
        return "", nil
    }

    // åˆ›å»º AES å¯†ç å—
    block, err := aes.NewCipher(e.masterKey)
    if err != nil {
        return "", err
    }

    // åˆ›å»º GCM æ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    // ç”Ÿæˆéšæœº nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    // åŠ å¯†æ•°æ®
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)

    // è¿”å› base64 ç¼–ç çš„å¯†æ–‡
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (e *EncryptionService) Decrypt(ciphertext string) (string, error) {
    if ciphertext == "" {
        return "", nil
    }

    // è§£ç  base64
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }

    // åˆ›å»º AES å¯†ç å—
    block, err := aes.NewCipher(e.masterKey)
    if err != nil {
        return "", err
    }

    // åˆ›å»º GCM æ¨¡å¼
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    // æå– nonce
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("invalid ciphertext")
    }

    nonce, ciphertext := data[:nonceSize], data[nonceSize:]

    // è§£å¯†æ•°æ®
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}

// å­—æ®µçº§åŠ å¯†è£…é¥°å™¨
type EncryptedField struct {
    value           string
    encryptionSvc   *EncryptionService
    isEncrypted     bool
}

func NewEncryptedField(value string, encryptionSvc *EncryptionService) *EncryptedField {
    return &EncryptedField{
        value:         value,
        encryptionSvc: encryptionSvc,
        isEncrypted:   false,
    }
}

func (ef *EncryptedField) Encrypt() error {
    if ef.isEncrypted {
        return nil
    }

    encrypted, err := ef.encryptionSvc.Encrypt(ef.value)
    if err != nil {
        return err
    }

    ef.value = encrypted
    ef.isEncrypted = true
    return nil
}

func (ef *EncryptedField) Decrypt() error {
    if !ef.isEncrypted {
        return nil
    }

    decrypted, err := ef.encryptionSvc.Decrypt(ef.value)
    if err != nil {
        return err
    }

    ef.value = decrypted
    ef.isEncrypted = false
    return nil
}

func (ef *EncryptedField) Value() string {
    return ef.value
}

func (ef *EncryptedField) SetValue(value string) {
    ef.value = value
    ef.isEncrypted = false
}
```

### 2. **æ•°æ®åº“åŠ å¯†æ¨¡å‹**

```go
// models/encrypted_models.go
package models

import (
    "database/sql/driver"
    "encoding/json"
    "fmt"
)

// è‡ªå®šä¹‰åŠ å¯†ç±»å‹
type EncryptedString struct {
    Value     string
    encrypted bool
}

func (es *EncryptedString) Scan(value interface{}) error {
    if value == nil {
        es.Value = ""
        return nil
    }

    switch v := value.(type) {
    case string:
        es.Value = v
        es.encrypted = true
    case []byte:
        es.Value = string(v)
        es.encrypted = true
    default:
        return fmt.Errorf("cannot scan %T into EncryptedString", value)
    }

    return nil
}

func (es EncryptedString) Value() (driver.Value, error) {
    if es.Value == "" {
        return nil, nil
    }

    // åœ¨ä¿å­˜åˆ°æ•°æ®åº“å‰åŠ å¯†
    encryptionSvc := GetEncryptionService() // å…¨å±€åŠ å¯†æœåŠ¡
    encrypted, err := encryptionSvc.Encrypt(es.Value)
    return encrypted, err
}

// åŠ å¯†çš„æ—¥è®°æ¨¡å‹
type JournalEntry struct {
    ID        string          `json:"id" gorm:"type:uuid;primary_key"`
    UserID    string          `json:"user_id" gorm:"type:uuid;not null"`
    Title     EncryptedString `json:"title" gorm:"type:text"`
    Content   EncryptedString `json:"content" gorm:"type:text"`
    Tags      EncryptedJSON   `json:"tags" gorm:"type:text"`
    Mood      string          `json:"mood"`
    CreatedAt time.Time       `json:"created_at"`
    UpdatedAt time.Time       `json:"updated_at"`
}

// é‡å†™ AfterFind å›è°ƒä»¥è§£å¯†æ•°æ®
func (je *JournalEntry) AfterFind(tx *gorm.DB) error {
    encryptionSvc := GetEncryptionService()

    // è§£å¯†æ ‡é¢˜
    if je.Title.Value != "" {
        decrypted, err := encryptionSvc.Decrypt(je.Title.Value)
        if err != nil {
            return err
        }
        je.Title.Value = decrypted
        je.Title.encrypted = false
    }

    // è§£å¯†å†…å®¹
    if je.Content.Value != "" {
        decrypted, err := encryptionSvc.Decrypt(je.Content.Value)
        if err != nil {
            return err
        }
        je.Content.Value = decrypted
        je.Content.encrypted = false
    }

    return nil
}

// JSON å­—æ®µåŠ å¯†
type EncryptedJSON struct {
    Data interface{}
}

func (ej *EncryptedJSON) Scan(value interface{}) error {
    if value == nil {
        return nil
    }

    var encrypted string
    switch v := value.(type) {
    case string:
        encrypted = v
    case []byte:
        encrypted = string(v)
    default:
        return fmt.Errorf("cannot scan %T into EncryptedJSON", value)
    }

    // è§£å¯† JSON æ•°æ®
    encryptionSvc := GetEncryptionService()
    decrypted, err := encryptionSvc.Decrypt(encrypted)
    if err != nil {
        return err
    }

    return json.Unmarshal([]byte(decrypted), &ej.Data)
}

func (ej EncryptedJSON) Value() (driver.Value, error) {
    if ej.Data == nil {
        return nil, nil
    }

    // åºåˆ—åŒ–ä¸º JSON
    jsonData, err := json.Marshal(ej.Data)
    if err != nil {
        return nil, err
    }

    // åŠ å¯† JSON æ•°æ®
    encryptionSvc := GetEncryptionService()
    return encryptionSvc.Encrypt(string(jsonData))
}
```

---

## ğŸ” å®‰å…¨ç›‘æ§ä¸å®¡è®¡

### 1. **å®‰å…¨äº‹ä»¶ç›‘æ§**

```go
// pkg/security/monitor.go
package security

import (
    "context"
    "encoding/json"
    "time"
    "github.com/sirupsen/logrus"
)

type SecurityEventType string

const (
    EventLoginAttempt       SecurityEventType = "login_attempt"
    EventLoginSuccess       SecurityEventType = "login_success"
    EventLoginFailure       SecurityEventType = "login_failure"
    EventPasswordChange     SecurityEventType = "password_change"
    EventSessionCreated     SecurityEventType = "session_created"
    EventSessionExpired     SecurityEventType = "session_expired"
    EventTokenRefresh       SecurityEventType = "token_refresh"
    EventSuspiciousActivity SecurityEventType = "suspicious_activity"
    EventDataAccess         SecurityEventType = "data_access"
    EventDataModification   SecurityEventType = "data_modification"
    EventPermissionDenied   SecurityEventType = "permission_denied"
    EventAPIRateLimited     SecurityEventType = "api_rate_limited"
    EventPasswordReset      SecurityEventType = "password_reset"
    EventAccountLocked      SecurityEventType = "account_locked"
)

type SecurityEvent struct {
    ID        string                 `json:"id"`
    Type      SecurityEventType      `json:"type"`
    UserID    string                 `json:"user_id,omitempty"`
    SessionID string                 `json:"session_id,omitempty"`
    IPAddress string                 `json:"ip_address"`
    UserAgent string                 `json:"user_agent"`
    Metadata  map[string]interface{} `json:"metadata"`
    Timestamp time.Time              `json:"timestamp"`
    Risk      RiskLevel             `json:"risk"`
}

type RiskLevel string

const (
    RiskLow      RiskLevel = "low"
    RiskMedium   RiskLevel = "medium"
    RiskHigh     RiskLevel = "high"
    RiskCritical RiskLevel = "critical"
)

type SecurityMonitor struct {
    logger       *logrus.Logger
    redis        *redis.Client
    postgres     *gorm.DB
    alertService AlertService
    riskAnalyzer *RiskAnalyzer
}

func NewSecurityMonitor(logger *logrus.Logger, redis *redis.Client, postgres *gorm.DB, alertService AlertService) *SecurityMonitor {
    return &SecurityMonitor{
        logger:       logger,
        redis:        redis,
        postgres:     postgres,
        alertService: alertService,
        riskAnalyzer: NewRiskAnalyzer(redis),
    }
}

func (sm *SecurityMonitor) LogEvent(ctx context.Context, event SecurityEvent) {
    event.ID = uuid.New().String()
    event.Timestamp = time.Now()

    // é£é™©è¯„ä¼°
    event.Risk = sm.riskAnalyzer.AssessRisk(event)

    // è®°å½•åˆ°æ—¥å¿—
    sm.logger.WithFields(logrus.Fields{
        "event_id":   event.ID,
        "event_type": event.Type,
        "user_id":    event.UserID,
        "risk":       event.Risk,
        "ip_address": event.IPAddress,
        "metadata":   event.Metadata,
    }).Info("Security event logged")

    // å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“
    go func() {
        if err := sm.saveEventToDB(event); err != nil {
            sm.logger.WithError(err).Error("Failed to save security event to database")
        }
    }()

    // ç¼“å­˜åˆ° Redis ç”¨äºå®æ—¶åˆ†æ
    sm.cacheEventForAnalysis(event)

    // é«˜é£é™©äº‹ä»¶ç«‹å³å‘Šè­¦
    if event.Risk == RiskHigh || event.Risk == RiskCritical {
        sm.handleHighRiskEvent(event)
    }

    // æ£€æŸ¥æ˜¯å¦è§¦å‘è‡ªåŠ¨é˜²æŠ¤æªæ–½
    sm.checkAutoProtection(event)
}

func (sm *SecurityMonitor) saveEventToDB(event SecurityEvent) error {
    return sm.postgres.Create(&event).Error
}

func (sm *SecurityMonitor) cacheEventForAnalysis(event SecurityEvent) {
    // ç¼“å­˜æœ€è¿‘çš„äº‹ä»¶ç”¨äºæ¨¡å¼åˆ†æ
    eventData, _ := json.Marshal(event)

    pipe := sm.redis.Pipeline()

    // ç”¨æˆ·äº‹ä»¶æ—¶é—´çº¿
    if event.UserID != "" {
        pipe.LPush(context.Background(),
            fmt.Sprintf("user_events:%s", event.UserID),
            eventData)
        pipe.LTrim(context.Background(),
            fmt.Sprintf("user_events:%s", event.UserID),
            0, 99) // ä¿ç•™æœ€è¿‘100ä¸ªäº‹ä»¶
    }

    // IP åœ°å€äº‹ä»¶æ—¶é—´çº¿
    if event.IPAddress != "" {
        pipe.LPush(context.Background(),
            fmt.Sprintf("ip_events:%s", event.IPAddress),
            eventData)
        pipe.LTrim(context.Background(),
            fmt.Sprintf("ip_events:%s", event.IPAddress),
            0, 49) // ä¿ç•™æœ€è¿‘50ä¸ªäº‹ä»¶
    }

    // å…¨å±€äº‹ä»¶æµ
    pipe.LPush(context.Background(), "global_events", eventData)
    pipe.LTrim(context.Background(), "global_events", 0, 999)

    pipe.Exec(context.Background())
}

func (sm *SecurityMonitor) handleHighRiskEvent(event SecurityEvent) {
    alert := Alert{
        Type:        AlertTypeSecurity,
        Severity:    AlertSeverityHigh,
        Title:       fmt.Sprintf("High Risk Security Event: %s", event.Type),
        Description: fmt.Sprintf("Risk level: %s, User: %s, IP: %s", event.Risk, event.UserID, event.IPAddress),
        Metadata:    event.Metadata,
        Timestamp:   event.Timestamp,
    }

    sm.alertService.SendAlert(alert)
}

func (sm *SecurityMonitor) checkAutoProtection(event SecurityEvent) {
    switch event.Type {
    case EventLoginFailure:
        sm.checkBruteForceProtection(event)
    case EventAPIRateLimited:
        sm.checkAPIAbuse(event)
    case EventSuspiciousActivity:
        sm.checkSuspiciousPattern(event)
    }
}

func (sm *SecurityMonitor) checkBruteForceProtection(event SecurityEvent) {
    if event.UserID == "" && event.IPAddress == "" {
        return
    }

    // æ£€æŸ¥æ¥è‡ªåŒä¸€IPçš„å¤±è´¥ç™»å½•æ¬¡æ•°
    if event.IPAddress != "" {
        key := fmt.Sprintf("login_failures:ip:%s", event.IPAddress)
        count, _ := sm.redis.Incr(context.Background(), key).Result()
        sm.redis.Expire(context.Background(), key, time.Hour)

        if count >= 10 { // 1å°æ—¶å†…å¤±è´¥10æ¬¡ï¼Œå°ç¦IP
            sm.blockIP(event.IPAddress, time.Hour*24) // å°ç¦24å°æ—¶
        }
    }

    // æ£€æŸ¥åŒä¸€ç”¨æˆ·çš„å¤±è´¥ç™»å½•æ¬¡æ•°
    if event.UserID != "" {
        key := fmt.Sprintf("login_failures:user:%s", event.UserID)
        count, _ := sm.redis.Incr(context.Background(), key).Result()
        sm.redis.Expire(context.Background(), key, time.Hour)

        if count >= 5 { // 1å°æ—¶å†…å¤±è´¥5æ¬¡ï¼Œé”å®šè´¦æˆ·
            sm.lockUserAccount(event.UserID, time.Hour*2) // é”å®š2å°æ—¶
        }
    }
}

func (sm *SecurityMonitor) blockIP(ipAddress string, duration time.Duration) {
    sm.redis.Set(context.Background(),
        fmt.Sprintf("blocked_ip:%s", ipAddress),
        "true",
        duration)

    sm.logger.WithFields(logrus.Fields{
        "ip_address": ipAddress,
        "duration":   duration,
    }).Warn("IP address blocked due to suspicious activity")

    // å‘é€å‘Šè­¦
    alert := Alert{
        Type:     AlertTypeSecurity,
        Severity: AlertSeverityMedium,
        Title:    "IP Address Blocked",
        Description: fmt.Sprintf("IP %s has been blocked for %v due to brute force attempts",
            ipAddress, duration),
        Timestamp: time.Now(),
    }
    sm.alertService.SendAlert(alert)
}

func (sm *SecurityMonitor) lockUserAccount(userID string, duration time.Duration) {
    sm.redis.Set(context.Background(),
        fmt.Sprintf("locked_user:%s", userID),
        "true",
        duration)

    sm.logger.WithFields(logrus.Fields{
        "user_id":  userID,
        "duration": duration,
    }).Warn("User account locked due to suspicious activity")
}
```

### 2. **é£é™©è¯„ä¼°å¼•æ“**

```go
// pkg/security/risk_analyzer.go
package security

import (
    "context"
    "encoding/json"
    "fmt"
    "net"
    "time"
)

type RiskAnalyzer struct {
    redis *redis.Client
}

type RiskFactors struct {
    IPReputation       int     `json:"ip_reputation"`        // IPå£°èª‰åˆ†æ•° (0-100)
    LocationAnomaly    int     `json:"location_anomaly"`     // ä½ç½®å¼‚å¸¸åˆ†æ•°
    TimeAnomaly        int     `json:"time_anomaly"`         // æ—¶é—´å¼‚å¸¸åˆ†æ•°
    FrequencyAnomaly   int     `json:"frequency_anomaly"`    // é¢‘ç‡å¼‚å¸¸åˆ†æ•°
    DeviceAnomaly      int     `json:"device_anomaly"`       // è®¾å¤‡å¼‚å¸¸åˆ†æ•°
    BehaviorAnomaly    int     `json:"behavior_anomaly"`     // è¡Œä¸ºå¼‚å¸¸åˆ†æ•°
    TotalScore         int     `json:"total_score"`          // æ€»é£é™©åˆ†æ•°
}

func NewRiskAnalyzer(redis *redis.Client) *RiskAnalyzer {
    return &RiskAnalyzer{
        redis: redis,
    }
}

func (ra *RiskAnalyzer) AssessRisk(event SecurityEvent) RiskLevel {
    factors := ra.calculateRiskFactors(event)

    score := factors.TotalScore

    switch {
    case score >= 80:
        return RiskCritical
    case score >= 60:
        return RiskHigh
    case score >= 40:
        return RiskMedium
    default:
        return RiskLow
    }
}

func (ra *RiskAnalyzer) calculateRiskFactors(event SecurityEvent) RiskFactors {
    factors := RiskFactors{}

    // IP å£°èª‰æ£€æŸ¥
    factors.IPReputation = ra.checkIPReputation(event.IPAddress)

    // ä½ç½®å¼‚å¸¸æ£€æŸ¥
    if event.UserID != "" {
        factors.LocationAnomaly = ra.checkLocationAnomaly(event.UserID, event.IPAddress)
    }

    // æ—¶é—´å¼‚å¸¸æ£€æŸ¥
    if event.UserID != "" {
        factors.TimeAnomaly = ra.checkTimeAnomaly(event.UserID)
    }

    // é¢‘ç‡å¼‚å¸¸æ£€æŸ¥
    factors.FrequencyAnomaly = ra.checkFrequencyAnomaly(event)

    // è®¾å¤‡å¼‚å¸¸æ£€æŸ¥
    if event.UserID != "" {
        factors.DeviceAnomaly = ra.checkDeviceAnomaly(event.UserID, event.UserAgent)
    }

    // è¡Œä¸ºå¼‚å¸¸æ£€æŸ¥
    factors.BehaviorAnomaly = ra.checkBehaviorAnomaly(event)

    // è®¡ç®—æ€»åˆ† (åŠ æƒå¹³å‡)
    factors.TotalScore = (factors.IPReputation*20 +
                         factors.LocationAnomaly*15 +
                         factors.TimeAnomaly*10 +
                         factors.FrequencyAnomaly*25 +
                         factors.DeviceAnomaly*15 +
                         factors.BehaviorAnomaly*15) / 100

    return factors
}

func (ra *RiskAnalyzer) checkIPReputation(ipAddress string) int {
    // æ£€æŸ¥IPæ˜¯å¦åœ¨é»‘åå•ä¸­
    isBlacklisted, _ := ra.redis.SIsMember(context.Background(), "ip_blacklist", ipAddress).Result()
    if isBlacklisted {
        return 100
    }

    // æ£€æŸ¥IPæ˜¯å¦ä¸ºå·²çŸ¥çš„æ¶æ„IP
    isMalicious, _ := ra.redis.SIsMember(context.Background(), "malicious_ips", ipAddress).Result()
    if isMalicious {
        return 90
    }

    // æ£€æŸ¥IPçš„å†å²è¡Œä¸º
    failureCount, _ := ra.redis.Get(context.Background(), fmt.Sprintf("ip_failures:%s", ipAddress)).Int()
    if failureCount > 10 {
        return 70
    } else if failureCount > 5 {
        return 50
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºTorç½‘ç»œæˆ–ä»£ç†
    if ra.isTorOrProxy(ipAddress) {
        return 60
    }

    return 0
}

func (ra *RiskAnalyzer) checkLocationAnomaly(userID, ipAddress string) int {
    // è·å–ç”¨æˆ·å†å²ä½ç½®ä¿¡æ¯
    historicalLocations, err := ra.redis.SMembers(context.Background(),
        fmt.Sprintf("user_locations:%s", userID)).Result()
    if err != nil || len(historicalLocations) == 0 {
        return 0 // æ–°ç”¨æˆ·ï¼Œæ— å†å²æ•°æ®
    }

    // è·å–å½“å‰IPçš„åœ°ç†ä½ç½®
    currentLocation := ra.getIPLocation(ipAddress)
    if currentLocation == nil {
        return 30 // æ— æ³•è·å–ä½ç½®ä¿¡æ¯
    }

    // æ£€æŸ¥æ˜¯å¦åœ¨å·²çŸ¥ä½ç½®èŒƒå›´å†…
    for _, loc := range historicalLocations {
        var historical GeoLocation
        json.Unmarshal([]byte(loc), &historical)

        distance := ra.calculateDistance(currentLocation, &historical)
        if distance < 100 { // 100å…¬é‡Œå†…è®¤ä¸ºæ˜¯æ­£å¸¸ä½ç½®
            return 0
        }
    }

    // æ£€æŸ¥ä½ç½®å˜åŒ–çš„åˆç†æ€§
    lastLocation := ra.getLastKnownLocation(userID)
    if lastLocation != nil {
        distance := ra.calculateDistance(currentLocation, lastLocation)
        timeDiff := time.Since(lastLocation.LastSeen)

        // è®¡ç®—ç†è®ºæœ€å¤§ç§»åŠ¨è·ç¦» (è€ƒè™‘äº¤é€šå·¥å…·)
        maxPossibleDistance := float64(timeDiff.Hours()) * 900 // 900km/h (é£æœºé€Ÿåº¦)

        if distance > maxPossibleDistance {
            return 80 // ç‰©ç†ä¸Šä¸å¯èƒ½çš„ä½ç½®å˜åŒ–
        } else if distance > 1000 {
            return 50 // é•¿è·ç¦»ç§»åŠ¨
        }
    }

    return 20 // æ–°ä½ç½®ä½†åˆç†
}

func (ra *RiskAnalyzer) checkTimeAnomaly(userID string) int {
    // è·å–ç”¨æˆ·å†å²æ´»åŠ¨æ—¶é—´æ¨¡å¼
    timePattern := ra.getUserTimePattern(userID)
    if timePattern == nil {
        return 0 // æ–°ç”¨æˆ·
    }

    currentHour := time.Now().Hour()

    // æ£€æŸ¥å½“å‰æ—¶é—´æ˜¯å¦åœ¨ç”¨æˆ·çš„æ´»è·ƒæ—¶é—´å†…
    if timePattern.IsActiveHour(currentHour) {
        return 0
    }

    // æ£€æŸ¥æ˜¯å¦åœ¨å®Œå…¨ä¸æ´»è·ƒçš„æ—¶é—´
    if timePattern.IsDeepSleepHour(currentHour) {
        return 70
    }

    return 30 // ä¸å¸¸è§ä½†å¯èƒ½çš„æ´»åŠ¨æ—¶é—´
}

func (ra *RiskAnalyzer) checkFrequencyAnomaly(event SecurityEvent) int {
    timeWindow := time.Minute * 5

    var key string
    if event.UserID != "" {
        key = fmt.Sprintf("event_freq:user:%s:%s", event.UserID, event.Type)
    } else {
        key = fmt.Sprintf("event_freq:ip:%s:%s", event.IPAddress, event.Type)
    }

    count, _ := ra.redis.Incr(context.Background(), key).Result()
    ra.redis.Expire(context.Background(), key, timeWindow)

    // æ ¹æ®äº‹ä»¶ç±»å‹è®¾ç½®ä¸åŒçš„é˜ˆå€¼
    var threshold int64
    switch event.Type {
    case EventLoginAttempt:
        threshold = 5  // 5åˆ†é’Ÿå†…æœ€å¤š5æ¬¡ç™»å½•å°è¯•
    case EventDataAccess:
        threshold = 50 // 5åˆ†é’Ÿå†…æœ€å¤š50æ¬¡æ•°æ®è®¿é—®
    case EventAPIRateLimited:
        threshold = 1  // 5åˆ†é’Ÿå†…ä¸åº”è¯¥æœ‰å¤šæ¬¡é™æµ
    default:
        threshold = 10
    }

    if count > threshold*2 {
        return 90
    } else if count > threshold {
        return 60
    }

    return 0
}

func (ra *RiskAnalyzer) isTorOrProxy(ipAddress string) bool {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æŸ¥è¯¢ä¸“ä¸šçš„IPä¿¡èª‰æ•°æ®åº“
    ip := net.ParseIP(ipAddress)
    if ip == nil {
        return false
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥çš„Torå‡ºå£èŠ‚ç‚¹
    isTor, _ := ra.redis.SIsMember(context.Background(), "tor_exit_nodes", ipAddress).Result()
    if isTor {
        return true
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥ä»£ç†
    isProxy, _ := ra.redis.SIsMember(context.Background(), "known_proxies", ipAddress).Result()
    return isProxy
}
```

è¿™ä¸ªå®‰å…¨ä¸åˆè§„è®¾è®¡æ–‡æ¡£ä¸º OrAura é¡¹ç›®æä¾›äº†å…¨é¢çš„å®‰å…¨ä¿æŠ¤æœºåˆ¶ï¼ŒåŒ…æ‹¬èº«ä»½è®¤è¯ã€OAuth2 é›†æˆã€æ•°æ®åŠ å¯†ã€å®‰å…¨ç›‘æ§ç­‰å…³é”®å®‰å…¨ç»„ä»¶çš„è¯¦ç»†å®ç°ã€‚æ¥ä¸‹æ¥æˆ‘å°†åˆ›å»ºæœ€åä¸€ä¸ªæ–‡æ¡£ã€‚
