# OrAura å‰ç«¯æ¨¡å—è®¾è®¡æ–‡æ¡£ (React Native)

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° OrAura ç§»åŠ¨ç«¯çš„å‰ç«¯æ¶æ„è®¾è®¡ï¼ŒåŒ…æ‹¬é¡µé¢è·¯ç”±ã€çŠ¶æ€ç®¡ç†ã€ç»„ä»¶è®¾è®¡ã€API é›†æˆã€æ ·å¼ç³»ç»Ÿå’Œå•å…ƒæµ‹è¯•ç­–ç•¥ã€‚

---

## ğŸ—ï¸ é¡¹ç›®æ¶æ„è®¾è®¡

### 1. **æŠ€æœ¯æ ˆé€‰æ‹©**

```json
{
  "framework": "React Native",
  "language": "TypeScript",
  "state_management": "Zustand + React Query",
  "navigation": "React Navigation v6",
  "styling": "Styled Components + NativeWind",
  "animation": "Reanimated 3 + Lottie",
  "testing": "Jest + Testing Library",
  "build": "Expo Development Build",
  "deployment": "EAS Build + CodePush"
}
```

### 2. **ç›®å½•ç»“æ„è®¾è®¡**

```
src/
â”œâ”€â”€ components/           # é€šç”¨ç»„ä»¶åº“
â”‚   â”œâ”€â”€ ui/              # åŸºç¡€ UI ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â”œâ”€â”€ Modal/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ forms/           # è¡¨å•ç»„ä»¶
â”‚   â”œâ”€â”€ charts/          # å›¾è¡¨ç»„ä»¶
â”‚   â””â”€â”€ animations/      # åŠ¨ç”»ç»„ä»¶
â”œâ”€â”€ screens/             # é¡µé¢ç»„ä»¶
â”‚   â”œâ”€â”€ Auth/           # è®¤è¯ç›¸å…³é¡µé¢
â”‚   â”œâ”€â”€ Divination/     # å åœç›¸å…³é¡µé¢
â”‚   â”œâ”€â”€ Emotion/        # æƒ…ç»ªè¿½è¸ªé¡µé¢
â”‚   â”œâ”€â”€ Meditation/     # å†¥æƒ³ç›¸å…³é¡µé¢
â”‚   â”œâ”€â”€ WhiteNoise/     # ç™½å™ªéŸ³é¡µé¢
â”‚   â”œâ”€â”€ Journal/        # æ—¥è®°ç›¸å…³é¡µé¢
â”‚   â””â”€â”€ Profile/        # ç”¨æˆ·èµ„æ–™é¡µé¢
â”œâ”€â”€ navigation/          # å¯¼èˆªé…ç½®
â”‚   â”œâ”€â”€ AppNavigator.tsx
â”‚   â”œâ”€â”€ AuthNavigator.tsx
â”‚   â””â”€â”€ TabNavigator.tsx
â”œâ”€â”€ hooks/              # è‡ªå®šä¹‰ Hooks
â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ useAudio.ts
â”‚   â”œâ”€â”€ useSubscription.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ services/           # API æœåŠ¡å±‚
â”‚   â”œâ”€â”€ api/           # API å®¢æˆ·ç«¯
â”‚   â”œâ”€â”€ auth/          # è®¤è¯æœåŠ¡
â”‚   â”œâ”€â”€ audio/         # éŸ³é¢‘æœåŠ¡
â”‚   â””â”€â”€ storage/       # æœ¬åœ°å­˜å‚¨
â”œâ”€â”€ stores/             # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ authStore.ts
â”‚   â”œâ”€â”€ userStore.ts
â”‚   â”œâ”€â”€ audioStore.ts
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ constants.ts
â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”œâ”€â”€ validation.ts
â”‚   â””â”€â”€ types.ts
â”œâ”€â”€ assets/             # é™æ€èµ„æº
â”‚   â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ animations/
â”‚   â”œâ”€â”€ sounds/
â”‚   â””â”€â”€ fonts/
â””â”€â”€ theme/              # ä¸»é¢˜é…ç½®
    â”œâ”€â”€ colors.ts
    â”œâ”€â”€ typography.ts
    â”œâ”€â”€ spacing.ts
    â””â”€â”€ index.ts
```

---

## ğŸ§­ é¡µé¢è·¯ç”±ä¸å¯¼èˆªè®¾è®¡

### 1. **å¯¼èˆªç»“æ„**

```tsx
// navigation/AppNavigator.tsx
import React from "react";
import { NavigationContainer } from "@react-navigation/native";
import { createNativeStackNavigator } from "@react-navigation/native-stack";
import { useAuthStore } from "../stores/authStore";
import AuthNavigator from "./AuthNavigator";
import MainTabNavigator from "./TabNavigator";
import LoadingScreen from "../screens/LoadingScreen";

const Stack = createNativeStackNavigator();

const AppNavigator: React.FC = () => {
  const { isAuthenticated, isLoading } = useAuthStore();

  if (isLoading) {
    return <LoadingScreen />;
  }

  return (
    <NavigationContainer>
      <Stack.Navigator screenOptions={{ headerShown: false }}>
        {isAuthenticated ? (
          <Stack.Screen name="Main" component={MainTabNavigator} />
        ) : (
          <Stack.Screen name="Auth" component={AuthNavigator} />
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default AppNavigator;
```

### 2. **ä¸»è¦æ ‡ç­¾å¯¼èˆª**

```tsx
// navigation/TabNavigator.tsx
import React from "react";
import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
import { BlurView } from "expo-blur";
import { Ionicons } from "@expo/vector-icons";
import { Colors } from "../theme";

import HomeScreen from "../screens/Home/HomeScreen";
import DivinationScreen from "../screens/Divination/DivinationScreen";
import EmotionScreen from "../screens/Emotion/EmotionScreen";
import MeditationScreen from "../screens/Meditation/MeditationScreen";
import ProfileScreen from "../screens/Profile/ProfileScreen";

const Tab = createBottomTabNavigator();

const MainTabNavigator: React.FC = () => {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: keyof typeof Ionicons.glyphMap;

          switch (route.name) {
            case "Home":
              iconName = focused ? "home" : "home-outline";
              break;
            case "Divination":
              iconName = focused ? "sparkles" : "sparkles-outline";
              break;
            case "Emotion":
              iconName = focused ? "heart" : "heart-outline";
              break;
            case "Meditation":
              iconName = focused ? "leaf" : "leaf-outline";
              break;
            case "Profile":
              iconName = focused ? "person" : "person-outline";
              break;
            default:
              iconName = "home-outline";
          }

          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: Colors.primary,
        tabBarInactiveTintColor: Colors.textSecondary,
        tabBarStyle: {
          position: "absolute",
          borderTopWidth: 0,
          backgroundColor: "transparent",
          elevation: 0,
        },
        tabBarBackground: () => (
          <BlurView
            intensity={80}
            tint="light"
            style={{
              flex: 1,
              backgroundColor: "rgba(255, 255, 255, 0.8)",
            }}
          />
        ),
      })}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{ tabBarLabel: "é¦–é¡µ" }}
      />
      <Tab.Screen
        name="Divination"
        component={DivinationScreen}
        options={{ tabBarLabel: "å åœ" }}
      />
      <Tab.Screen
        name="Emotion"
        component={EmotionScreen}
        options={{ tabBarLabel: "æƒ…ç»ª" }}
      />
      <Tab.Screen
        name="Meditation"
        component={MeditationScreen}
        options={{ tabBarLabel: "å†¥æƒ³" }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{ tabBarLabel: "æˆ‘çš„" }}
      />
    </Tab.Navigator>
  );
};

export default MainTabNavigator;
```

### 3. **è·¯ç”±ç±»å‹å®šä¹‰**

```tsx
// utils/types/navigation.ts
export type RootStackParamList = {
  Auth: undefined;
  Main: undefined;
};

export type AuthStackParamList = {
  Welcome: undefined;
  Login: undefined;
  Register: undefined;
  ForgotPassword: undefined;
  OAuthCallback: { provider: "google" | "apple" };
};

export type MainTabParamList = {
  Home: undefined;
  Divination: undefined;
  Emotion: undefined;
  Meditation: undefined;
  Profile: undefined;
};

export type DivinationStackParamList = {
  DivinationHome: undefined;
  TarotReading: { question?: string };
  DivinationResult: {
    id: string;
    type: "tarot" | "astrology" | "iching";
  };
  DivinationHistory: undefined;
};

export type MeditationStackParamList = {
  MeditationHome: undefined;
  MeditationPlayer: {
    courseId: string;
    autoPlay?: boolean;
  };
  MeditationLibrary: {
    category?: string;
  };
  MeditationProgress: undefined;
};
```

---

## ğŸª çŠ¶æ€ç®¡ç†è®¾è®¡

### 1. **Zustand Store è®¾è®¡**

```tsx
// stores/authStore.ts
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { User, LoginCredentials, RegisterData } from "../utils/types/auth";
import { authAPI } from "../services/api/authAPI";

interface AuthState {
  // çŠ¶æ€
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;

  // åŠ¨ä½œ
  login: (credentials: LoginCredentials) => Promise<void>;
  register: (data: RegisterData) => Promise<void>;
  logout: () => Promise<void>;
  refreshToken: () => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;

  // OAuth
  loginWithGoogle: () => Promise<void>;
  loginWithApple: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      isLoading: false,

      login: async (credentials) => {
        set({ isLoading: true });
        try {
          const response = await authAPI.login(credentials);
          set({
            user: response.user,
            token: response.token,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },

      register: async (data) => {
        set({ isLoading: true });
        try {
          const response = await authAPI.register(data);
          set({
            user: response.user,
            token: response.token,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },

      logout: async () => {
        try {
          await authAPI.logout();
        } finally {
          set({
            user: null,
            token: null,
            isAuthenticated: false,
          });
        }
      },

      refreshToken: async () => {
        const { token } = get();
        if (!token) return;

        try {
          const response = await authAPI.refreshToken(token);
          set({ token: response.token });
        } catch (error) {
          // Token æ— æ•ˆï¼Œé€€å‡ºç™»å½•
          get().logout();
        }
      },

      updateProfile: async (data) => {
        const { user } = get();
        if (!user) return;

        try {
          const updatedUser = await authAPI.updateProfile(data);
          set({ user: updatedUser });
        } catch (error) {
          throw error;
        }
      },

      loginWithGoogle: async () => {
        set({ isLoading: true });
        try {
          const response = await authAPI.googleOAuth();
          set({
            user: response.user,
            token: response.token,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },

      loginWithApple: async () => {
        set({ isLoading: true });
        try {
          const response = await authAPI.appleOAuth();
          set({
            user: response.user,
            token: response.token,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
    }),
    {
      name: "auth-storage",
      storage: createJSONStorage(() => AsyncStorage),
      partialize: (state) => ({
        user: state.user,
        token: state.token,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);
```

### 2. **éŸ³é¢‘æ’­æ”¾çŠ¶æ€ç®¡ç†**

```tsx
// stores/audioStore.ts
import { create } from "zustand";
import { Audio } from "expo-av";
import { MeditationCourse, WhiteNoiseSound } from "../utils/types/audio";

interface AudioState {
  // å†¥æƒ³æ’­æ”¾å™¨çŠ¶æ€
  currentCourse: MeditationCourse | null;
  isPlaying: boolean;
  position: number;
  duration: number;
  playbackRate: number;

  // ç™½å™ªéŸ³æ··éŸ³å™¨çŠ¶æ€
  whiteNoiseSounds: WhiteNoiseSound[];
  activeSounds: Record<string, { volume: number; isPlaying: boolean }>;

  // éŸ³é¢‘å®ä¾‹
  soundObject: Audio.Sound | null;

  // åŠ¨ä½œ
  loadCourse: (course: MeditationCourse) => Promise<void>;
  play: () => Promise<void>;
  pause: () => Promise<void>;
  seek: (position: number) => Promise<void>;
  setPlaybackRate: (rate: number) => Promise<void>;

  // ç™½å™ªéŸ³æ§åˆ¶
  playWhiteNoise: (soundId: string, volume?: number) => Promise<void>;
  pauseWhiteNoise: (soundId: string) => Promise<void>;
  setWhiteNoiseVolume: (soundId: string, volume: number) => Promise<void>;
  createPreset: (name: string, sounds: Record<string, number>) => Promise<void>;
}

export const useAudioStore = create<AudioState>((set, get) => ({
  currentCourse: null,
  isPlaying: false,
  position: 0,
  duration: 0,
  playbackRate: 1.0,
  whiteNoiseSounds: [],
  activeSounds: {},
  soundObject: null,

  loadCourse: async (course) => {
    const { soundObject } = get();

    // åœæ­¢å½“å‰æ’­æ”¾
    if (soundObject) {
      await soundObject.unloadAsync();
    }

    try {
      const { sound } = await Audio.Sound.createAsync(
        { uri: course.audioUrl },
        { shouldPlay: false }
      );

      const status = await sound.getStatusAsync();
      if (status.isLoaded) {
        set({
          currentCourse: course,
          soundObject: sound,
          duration: status.durationMillis || 0,
          position: 0,
          isPlaying: false,
        });

        // è®¾ç½®æ’­æ”¾çŠ¶æ€ç›‘å¬
        sound.setOnPlaybackStatusUpdate((status) => {
          if (status.isLoaded) {
            set({
              position: status.positionMillis || 0,
              isPlaying: status.isPlaying,
            });
          }
        });
      }
    } catch (error) {
      console.error("Failed to load audio:", error);
      throw error;
    }
  },

  play: async () => {
    const { soundObject } = get();
    if (soundObject) {
      await soundObject.playAsync();
    }
  },

  pause: async () => {
    const { soundObject } = get();
    if (soundObject) {
      await soundObject.pauseAsync();
    }
  },

  seek: async (position) => {
    const { soundObject } = get();
    if (soundObject) {
      await soundObject.setPositionAsync(position);
      set({ position });
    }
  },

  setPlaybackRate: async (rate) => {
    const { soundObject } = get();
    if (soundObject) {
      await soundObject.setRateAsync(rate, true);
      set({ playbackRate: rate });
    }
  },

  playWhiteNoise: async (soundId, volume = 0.5) => {
    const { activeSounds } = get();

    // è¿™é‡Œéœ€è¦å®ç°ç™½å™ªéŸ³æ’­æ”¾é€»è¾‘
    set({
      activeSounds: {
        ...activeSounds,
        [soundId]: { volume, isPlaying: true },
      },
    });
  },

  pauseWhiteNoise: async (soundId) => {
    const { activeSounds } = get();

    set({
      activeSounds: {
        ...activeSounds,
        [soundId]: { ...activeSounds[soundId], isPlaying: false },
      },
    });
  },

  setWhiteNoiseVolume: async (soundId, volume) => {
    const { activeSounds } = get();

    set({
      activeSounds: {
        ...activeSounds,
        [soundId]: { ...activeSounds[soundId], volume },
      },
    });
  },

  createPreset: async (name, sounds) => {
    // ä¿å­˜é¢„è®¾åˆ°åç«¯æˆ–æœ¬åœ°å­˜å‚¨
    console.log("Creating preset:", name, sounds);
  },
}));
```

---

## ğŸ”Œ API é›†æˆä¸ React Query

### 1. **API å®¢æˆ·ç«¯é…ç½®**

```tsx
// services/api/client.ts
import axios, { AxiosInstance, AxiosRequestConfig } from "axios";
import { useAuthStore } from "../../stores/authStore";

class APIClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: __DEV__
        ? "http://localhost:8080/api/v1"
        : "https://api.oraura.com/api/v1",
      timeout: 30000,
      headers: {
        "Content-Type": "application/json",
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // è¯·æ±‚æ‹¦æˆªå™¨ - æ·»åŠ è®¤è¯ token
    this.instance.interceptors.request.use(
      (config) => {
        const token = useAuthStore.getState().token;
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // å“åº”æ‹¦æˆªå™¨ - å¤„ç†è®¤è¯å¤±è´¥
    this.instance.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;

          try {
            // å°è¯•åˆ·æ–° token
            await useAuthStore.getState().refreshToken();

            // é‡æ–°å‘é€åŸå§‹è¯·æ±‚
            const token = useAuthStore.getState().token;
            if (token) {
              originalRequest.headers.Authorization = `Bearer ${token}`;
              return this.instance(originalRequest);
            }
          } catch (refreshError) {
            // åˆ·æ–°å¤±è´¥ï¼Œé€€å‡ºç™»å½•
            useAuthStore.getState().logout();
          }
        }

        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.get(url, config);
    return response.data;
  }

  async post<T>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    const response = await this.instance.post(url, data, config);
    return response.data;
  }

  async put<T>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    const response = await this.instance.put(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.instance.delete(url, config);
    return response.data;
  }
}

export const apiClient = new APIClient();
```

### 2. **React Query é›†æˆ**

```tsx
// services/api/queries.ts
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "./client";
import {
  DivinationRequest,
  DivinationResponse,
  EmotionRecord,
  MeditationCourse,
} from "../../utils/types";

// æŸ¥è¯¢é”®
export const queryKeys = {
  divinations: ["divinations"] as const,
  divinationHistory: ["divinations", "history"] as const,
  emotions: ["emotions"] as const,
  emotionTrends: (period: string) => ["emotions", "trends", period] as const,
  meditationCourses: ["meditation", "courses"] as const,
  userProfile: ["user", "profile"] as const,
};

// å åœç›¸å…³æŸ¥è¯¢
export const useDivinationHistory = () => {
  return useQuery({
    queryKey: queryKeys.divinationHistory,
    queryFn: () => apiClient.get<DivinationResponse[]>("/divination/history"),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
  });
};

export const useCreateDivination = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (request: DivinationRequest) =>
      apiClient.post<DivinationResponse>("/divination/ask", request),
    onSuccess: () => {
      // åˆ·æ–°å†å²è®°å½•
      queryClient.invalidateQueries({ queryKey: queryKeys.divinationHistory });
    },
  });
};

// æƒ…ç»ªè¿½è¸ªæŸ¥è¯¢
export const useEmotionTrends = (period: "weekly" | "monthly") => {
  return useQuery({
    queryKey: queryKeys.emotionTrends(period),
    queryFn: () => apiClient.get(`/emotion/${period}`),
    staleTime: 10 * 60 * 1000, // 10åˆ†é’Ÿ
  });
};

export const useRecordEmotion = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (emotion: EmotionRecord) =>
      apiClient.post("/emotion/record", emotion),
    onSuccess: () => {
      // åˆ·æ–°ç›¸å…³æŸ¥è¯¢
      queryClient.invalidateQueries({ queryKey: queryKeys.emotions });
      queryClient.invalidateQueries({
        queryKey: queryKeys.emotionTrends("weekly"),
      });
    },
  });
};

// å†¥æƒ³è¯¾ç¨‹æŸ¥è¯¢
export const useMeditationCourses = (category?: string) => {
  return useQuery({
    queryKey: [...queryKeys.meditationCourses, { category }],
    queryFn: () =>
      apiClient.get<MeditationCourse[]>(
        `/meditation/courses${category ? `?category=${category}` : ""}`
      ),
    staleTime: 30 * 60 * 1000, // 30åˆ†é’Ÿ
  });
};

export const useStartMeditationSession = () => {
  return useMutation({
    mutationFn: (courseId: string) =>
      apiClient.post("/meditation/session/start", { courseId }),
  });
};
```

### 3. **è‡ªå®šä¹‰ Hook ç¤ºä¾‹**

```tsx
// hooks/useSubscription.ts
import { useState, useEffect } from "react";
import { Platform } from "react-native";
import { useQuery } from "@tanstack/react-query";
import { useAuthStore } from "../stores/authStore";
import { apiClient } from "../services/api/client";

interface SubscriptionInfo {
  type: "free" | "premium";
  expiresAt?: string;
  features: string[];
  canAccessFeature: (feature: string) => boolean;
}

export const useSubscription = () => {
  const { user } = useAuthStore();

  const { data: subscription, isLoading } = useQuery({
    queryKey: ["subscription", "status"],
    queryFn: () => apiClient.get<SubscriptionInfo>("/subscription/status"),
    enabled: !!user,
    staleTime: 5 * 60 * 1000,
  });

  const canAccessFeature = (feature: string): boolean => {
    if (!subscription) return false;
    return (
      subscription.features.includes(feature) || subscription.type === "premium"
    );
  };

  const isPremium = subscription?.type === "premium";
  const isExpired = subscription?.expiresAt
    ? new Date(subscription.expiresAt) < new Date()
    : false;

  return {
    subscription,
    isLoading,
    isPremium,
    isExpired,
    canAccessFeature,
  };
};

// hooks/useAudio.ts
import { useState, useEffect, useRef } from "react";
import { Audio } from "expo-av";
import { useAudioStore } from "../stores/audioStore";

export const useAudio = () => {
  const [isInitialized, setIsInitialized] = useState(false);
  const audioStore = useAudioStore();

  useEffect(() => {
    const initializeAudio = async () => {
      try {
        await Audio.setAudioModeAsync({
          allowsRecordingIOS: false,
          staysActiveInBackground: true,
          playsInSilentModeIOS: true,
          shouldDuckAndroid: true,
          playThroughEarpieceAndroid: false,
        });
        setIsInitialized(true);
      } catch (error) {
        console.error("Failed to initialize audio:", error);
      }
    };

    initializeAudio();
  }, []);

  return {
    isInitialized,
    ...audioStore,
  };
};
```

---

## ğŸ¨ ç»„ä»¶è®¾è®¡ä¸æ ·å¼ç³»ç»Ÿ

### 1. **è®¾è®¡ç³»ç»Ÿé…ç½®**

```tsx
// theme/index.ts
export const Colors = {
  // ä¸»è‰²è°ƒ
  primary: "#8B5CF6", // çµæ€§ç´«
  primaryLight: "#A78BFA",
  primaryDark: "#7C3AED",

  secondary: "#06B6D4", // æ˜Ÿå…‰è“
  secondaryLight: "#67E8F9",
  secondaryDark: "#0891B2",

  accent: "#F59E0B", // ç²‰é‡‘
  accentLight: "#FCD34D",
  accentDark: "#D97706",

  // ä¸­æ€§è‰²
  background: "#FFFFFF",
  backgroundSecondary: "#F8FAFC",
  backgroundTertiary: "#F1F5F9",

  surface: "#FFFFFF",
  surfaceSecondary: "#F8FAFC",

  // æ–‡å­—é¢œè‰²
  text: "#1E293B",
  textSecondary: "#64748B",
  textTertiary: "#94A3B8",
  textInverse: "#FFFFFF",

  // çŠ¶æ€é¢œè‰²
  success: "#10B981",
  warning: "#F59E0B",
  error: "#EF4444",
  info: "#3B82F6",

  // æƒ…ç»ªè‰²å½©
  emotion: {
    joy: "#FFD700",
    love: "#FF69B4",
    peace: "#87CEEB",
    energy: "#FF6347",
    calm: "#98FB98",
    sadness: "#4682B4",
    anger: "#DC143C",
    fear: "#9370DB",
  },
};

export const Typography = {
  fonts: {
    primary: "Inter",
    secondary: "Noto Serif SC",
    mono: "JetBrains Mono",
  },
  sizes: {
    xs: 12,
    sm: 14,
    base: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
    "3xl": 30,
    "4xl": 36,
    "5xl": 48,
  },
  weights: {
    normal: "400",
    medium: "500",
    semibold: "600",
    bold: "700",
  },
  lineHeights: {
    tight: 1.25,
    normal: 1.5,
    relaxed: 1.75,
  },
};

export const Spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  "2xl": 40,
  "3xl": 48,
  "4xl": 64,
};

export const BorderRadius = {
  sm: 4,
  md: 8,
  lg: 12,
  xl: 16,
  "2xl": 24,
  full: 9999,
};

export const Shadows = {
  sm: {
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  md: {
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
  lg: {
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 16,
    elevation: 8,
  },
};
```

### 2. **åŸºç¡€ UI ç»„ä»¶**

```tsx
// components/ui/Button/Button.tsx
import React from "react";
import { TouchableOpacity, Text, ActivityIndicator } from "react-native";
import styled from "styled-components/native";
import { Colors, Typography, Spacing, BorderRadius } from "../../../theme";

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: "primary" | "secondary" | "outline" | "ghost";
  size?: "sm" | "md" | "lg";
  disabled?: boolean;
  loading?: boolean;
  icon?: React.ReactNode;
  fullWidth?: boolean;
}

const StyledButton = styled(TouchableOpacity)<{
  variant: string;
  size: string;
  disabled: boolean;
  fullWidth: boolean;
}>`
  flex-direction: row;
  align-items: center;
  justify-content: center;
  border-radius: ${BorderRadius.lg}px;
  padding: ${(props) => {
    switch (props.size) {
      case "sm":
        return `${Spacing.sm}px ${Spacing.md}px`;
      case "lg":
        return `${Spacing.lg}px ${Spacing.xl}px`;
      default:
        return `${Spacing.md}px ${Spacing.lg}px`;
    }
  }};
  background-color: ${(props) => {
    if (props.disabled) return Colors.backgroundTertiary;
    switch (props.variant) {
      case "primary":
        return Colors.primary;
      case "secondary":
        return Colors.secondary;
      case "outline":
        return "transparent";
      case "ghost":
        return "transparent";
      default:
        return Colors.primary;
    }
  }};
  border-width: ${(props) => (props.variant === "outline" ? "1px" : "0px")};
  border-color: ${(props) =>
    props.variant === "outline" ? Colors.primary : "transparent"};
  width: ${(props) => (props.fullWidth ? "100%" : "auto")};
  opacity: ${(props) => (props.disabled ? 0.6 : 1)};
`;

const ButtonText = styled(Text)<{
  variant: string;
  size: string;
  disabled: boolean;
}>`
  font-family: ${Typography.fonts.primary};
  font-weight: ${Typography.weights.semibold};
  font-size: ${(props) => {
    switch (props.size) {
      case "sm":
        return Typography.sizes.sm;
      case "lg":
        return Typography.sizes.lg;
      default:
        return Typography.sizes.base;
    }
  }}px;
  color: ${(props) => {
    if (props.disabled) return Colors.textTertiary;
    switch (props.variant) {
      case "primary":
        return Colors.textInverse;
      case "secondary":
        return Colors.textInverse;
      case "outline":
        return Colors.primary;
      case "ghost":
        return Colors.primary;
      default:
        return Colors.textInverse;
    }
  }};
  margin-left: ${(props) => (props.variant === "ghost" ? 0 : Spacing.xs)}px;
`;

const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = "primary",
  size = "md",
  disabled = false,
  loading = false,
  icon,
  fullWidth = false,
}) => {
  return (
    <StyledButton
      variant={variant}
      size={size}
      disabled={disabled || loading}
      fullWidth={fullWidth}
      onPress={onPress}
      activeOpacity={0.8}
    >
      {loading ? (
        <ActivityIndicator
          size="small"
          color={
            variant === "outline" || variant === "ghost"
              ? Colors.primary
              : Colors.textInverse
          }
        />
      ) : (
        <>
          {icon}
          <ButtonText variant={variant} size={size} disabled={disabled}>
            {title}
          </ButtonText>
        </>
      )}
    </StyledButton>
  );
};

export default Button;
```

### 3. **åŠ¨ç”»ç»„ä»¶ç¤ºä¾‹**

```tsx
// components/animations/BreathingCircle.tsx
import React, { useEffect } from "react";
import { View } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated";
import styled from "styled-components/native";
import { Colors } from "../../theme";

interface BreathingCircleProps {
  isActive: boolean;
  breathPattern?: {
    inhale: number; // å¸æ°”æ—¶é•¿ï¼ˆç§’ï¼‰
    hold: number; // å±æ¯æ—¶é•¿ï¼ˆç§’ï¼‰
    exhale: number; // å‘¼æ°”æ—¶é•¿ï¼ˆç§’ï¼‰
    pause: number; // æš‚åœæ—¶é•¿ï¼ˆç§’ï¼‰
  };
  size?: number;
}

const Container = styled(View)`
  align-items: center;
  justify-content: center;
`;

const BreathingCircle: React.FC<BreathingCircleProps> = ({
  isActive,
  breathPattern = { inhale: 4, hold: 2, exhale: 6, pause: 2 },
  size = 200,
}) => {
  const scale = useSharedValue(0.8);
  const opacity = useSharedValue(0.6);

  useEffect(() => {
    if (isActive) {
      const totalDuration =
        Object.values(breathPattern).reduce((a, b) => a + b, 0) * 1000;

      scale.value = withRepeat(
        withTiming(1.2, {
          duration: totalDuration,
          easing: Easing.inOut(Easing.ease),
        }),
        -1,
        true
      );

      opacity.value = withRepeat(
        withTiming(1, {
          duration: totalDuration / 2,
          easing: Easing.inOut(Easing.ease),
        }),
        -1,
        true
      );
    } else {
      scale.value = withTiming(0.8);
      opacity.value = withTiming(0.6);
    }
  }, [isActive, breathPattern]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }],
    opacity: opacity.value,
  }));

  return (
    <Container>
      <Animated.View
        style={[
          {
            width: size,
            height: size,
            borderRadius: size / 2,
            backgroundColor: Colors.primary,
          },
          animatedStyle,
        ]}
      />
    </Container>
  );
};

export default BreathingCircle;
```

---

## ğŸ§ª å•å…ƒæµ‹è¯•ç­–ç•¥

### 1. **æµ‹è¯•æ¡†æ¶é…ç½®**

```json
// jest.config.js
module.exports = {
  preset: 'react-native',
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  setupFilesAfterEnv: ['<rootDir>/src/tests/setup.ts'],
  testMatch: [
    '<rootDir>/src/**/__tests__/**/*.(ts|tsx|js)',
    '<rootDir>/src/**/*.(test|spec).(ts|tsx|js)',
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/tests/**',
    '!src/**/__tests__/**',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  transformIgnorePatterns: [
    'node_modules/(?!(react-native|@react-native|@react-navigation|expo-av|@expo)/)',
  ],
};
```

### 2. **ç»„ä»¶æµ‹è¯•ç¤ºä¾‹**

```tsx
// components/ui/Button/__tests__/Button.test.tsx
import React from "react";
import { render, fireEvent } from "@testing-library/react-native";
import { ThemeProvider } from "styled-components/native";
import Button from "../Button";
import { theme } from "../../../../theme";

const renderWithTheme = (component: React.ReactElement) => {
  return render(<ThemeProvider theme={theme}>{component}</ThemeProvider>);
};

describe("Button Component", () => {
  it("renders correctly with default props", () => {
    const { getByText } = renderWithTheme(
      <Button title="Test Button" onPress={() => {}} />
    );

    expect(getByText("Test Button")).toBeTruthy();
  });

  it("calls onPress when button is pressed", () => {
    const mockOnPress = jest.fn();
    const { getByText } = renderWithTheme(
      <Button title="Test Button" onPress={mockOnPress} />
    );

    fireEvent.press(getByText("Test Button"));
    expect(mockOnPress).toHaveBeenCalledTimes(1);
  });

  it("shows loading indicator when loading prop is true", () => {
    const { getByTestId, queryByText } = renderWithTheme(
      <Button title="Test Button" onPress={() => {}} loading />
    );

    expect(getByTestId("activity-indicator")).toBeTruthy();
    expect(queryByText("Test Button")).toBeFalsy();
  });

  it("is disabled when disabled prop is true", () => {
    const mockOnPress = jest.fn();
    const { getByText } = renderWithTheme(
      <Button title="Test Button" onPress={mockOnPress} disabled />
    );

    fireEvent.press(getByText("Test Button"));
    expect(mockOnPress).not.toHaveBeenCalled();
  });

  it("applies correct styles for different variants", () => {
    const { getByTestId, rerender } = renderWithTheme(
      <Button
        title="Test"
        onPress={() => {}}
        variant="primary"
        testID="button"
      />
    );

    const button = getByTestId("button");
    expect(button.props.style).toMatchObject({
      backgroundColor: expect.any(String),
    });

    rerender(
      <ThemeProvider theme={theme}>
        <Button
          title="Test"
          onPress={() => {}}
          variant="outline"
          testID="button"
        />
      </ThemeProvider>
    );

    expect(button.props.style).toMatchObject({
      borderWidth: 1,
    });
  });
});
```

### 3. **Hook æµ‹è¯•ç¤ºä¾‹**

```tsx
// hooks/__tests__/useSubscription.test.ts
import { renderHook, waitFor } from "@testing-library/react-native";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useSubscription } from "../useSubscription";
import { useAuthStore } from "../../stores/authStore";
import { apiClient } from "../../services/api/client";

// Mock dependencies
jest.mock("../../stores/authStore");
jest.mock("../../services/api/client");

const mockUseAuthStore = useAuthStore as jest.MockedFunction<
  typeof useAuthStore
>;
const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;

describe("useSubscription Hook", () => {
  let queryClient: QueryClient;

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false },
      },
    });

    jest.clearAllMocks();
  });

  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );

  it("returns loading state initially", () => {
    mockUseAuthStore.mockReturnValue({
      user: { id: "1", email: "test@example.com" },
      token: "test-token",
      isAuthenticated: true,
    });

    const { result } = renderHook(() => useSubscription(), { wrapper });

    expect(result.current.isLoading).toBe(true);
    expect(result.current.subscription).toBeUndefined();
  });

  it("fetches subscription data when user is authenticated", async () => {
    const mockSubscription = {
      type: "premium" as const,
      expiresAt: "2024-12-31T23:59:59Z",
      features: ["unlimited_divination", "premium_meditation"],
    };

    mockUseAuthStore.mockReturnValue({
      user: { id: "1", email: "test@example.com" },
      token: "test-token",
      isAuthenticated: true,
    });

    mockApiClient.get.mockResolvedValue({
      success: true,
      data: mockSubscription,
    });

    const { result } = renderHook(() => useSubscription(), { wrapper });

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.subscription).toEqual(mockSubscription);
    expect(result.current.isPremium).toBe(true);
    expect(result.current.canAccessFeature("unlimited_divination")).toBe(true);
  });

  it("does not fetch data when user is not authenticated", () => {
    mockUseAuthStore.mockReturnValue({
      user: null,
      token: null,
      isAuthenticated: false,
    });

    renderHook(() => useSubscription(), { wrapper });

    expect(mockApiClient.get).not.toHaveBeenCalled();
  });
});
```

### 4. **E2E æµ‹è¯•é…ç½®**

```tsx
// e2e/divination.e2e.ts
import { by, device, element, expect } from "detox";

describe("Divination Flow", () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  beforeEach(async () => {
    await device.reloadReactNative();
  });

  it("should complete a tarot reading", async () => {
    // ç™»å½•
    await element(by.id("login-email")).typeText("test@example.com");
    await element(by.id("login-password")).typeText("password123");
    await element(by.id("login-button")).tap();

    // ç­‰å¾…ä¸»é¡µåŠ è½½
    await waitFor(element(by.id("home-screen")))
      .toBeVisible()
      .withTimeout(5000);

    // å¯¼èˆªåˆ°å åœé¡µé¢
    await element(by.id("tab-divination")).tap();

    // è¾“å…¥é—®é¢˜
    await element(by.id("divination-question-input")).typeText(
      "What should I focus on today?"
    );

    // é€‰æ‹©å¡”ç½—ç‰Œ
    await element(by.id("divination-type-tarot")).tap();

    // å¼€å§‹å åœ
    await element(by.id("start-divination-button")).tap();

    // ç­‰å¾…ç»“æœåŠ è½½
    await waitFor(element(by.id("divination-result")))
      .toBeVisible()
      .withTimeout(10000);

    // éªŒè¯ç»“æœæ˜¾ç¤º
    await expect(element(by.id("divination-interpretation"))).toBeVisible();
    await expect(element(by.id("divination-advice"))).toBeVisible();

    // ä¿å­˜ç»“æœ
    await element(by.id("save-divination-button")).tap();

    // éªŒè¯ä¿å­˜æˆåŠŸ
    await expect(element(by.text("å åœç»“æœå·²ä¿å­˜"))).toBeVisible();
  });

  it("should show premium upgrade prompt for free users", async () => {
    // æ¨¡æ‹Ÿå…è´¹ç”¨æˆ·å·²è¾¾åˆ°æ¯æ—¥é™åˆ¶
    await element(by.id("start-divination-button")).tap();

    // éªŒè¯å‡çº§æç¤ºæ˜¾ç¤º
    await expect(element(by.id("premium-upgrade-modal"))).toBeVisible();
    await expect(element(by.text("è§£é”æ— é™å åœ"))).toBeVisible();

    // ç‚¹å‡»å‡çº§æŒ‰é’®
    await element(by.id("upgrade-button")).tap();

    // éªŒè¯è·³è½¬åˆ°è®¢é˜…é¡µé¢
    await expect(element(by.id("subscription-screen"))).toBeVisible();
  });
});
```

### 5. **æµ‹è¯•å·¥å…·è„šæœ¬**

```json
// package.json scripts
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "detox test",
    "test:e2e:build": "detox build",
    "test:ci": "jest --coverage --watchAll=false"
  }
}
```

```bash
# scripts/test.sh
#!/bin/bash

echo "ğŸ§ª Running React Native Tests..."

# å•å…ƒæµ‹è¯•
echo "ğŸ“± Running unit tests..."
npm run test:coverage

# æ£€æŸ¥è¦†ç›–ç‡é˜ˆå€¼
COVERAGE=$(npm run test:coverage --silent | grep "All files" | awk '{print $10}' | sed 's/%//')
if (( $(echo "$COVERAGE < 80" | bc -l) )); then
  echo "âŒ Test coverage is below 80%: $COVERAGE%"
  exit 1
fi

echo "âœ… Unit tests passed with $COVERAGE% coverage"

# E2E æµ‹è¯•
if [ "$1" = "--e2e" ]; then
  echo "ğŸ­ Running E2E tests..."
  npm run test:e2e:build
  npm run test:e2e
  echo "âœ… E2E tests completed"
fi

echo "ğŸ‰ All tests passed!"
```

è¿™ä¸ªå‰ç«¯æ¨¡å—è®¾è®¡æ–‡æ¡£æä¾›äº†å®Œæ•´çš„ React Native åº”ç”¨æ¶æ„ï¼ŒåŒ…æ‹¬å¯¼èˆªã€çŠ¶æ€ç®¡ç†ã€API é›†æˆã€ç»„ä»¶è®¾è®¡å’Œæµ‹è¯•ç­–ç•¥ã€‚æ¥ä¸‹æ¥æˆ‘å°†ç»§ç»­åˆ›å»ºå…¶ä»–æ–‡æ¡£ã€‚
